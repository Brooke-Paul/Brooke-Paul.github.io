{"meta":{"title":"Brooke-Paul","subtitle":"record my daily life","description":"No accumulation of thousands of miles","author":"Brooke-Paul","url":"http://www.uuuup.vip"},"pages":[{"title":"","date":"2018-10-19T07:37:49.825Z","updated":"2018-10-19T07:31:22.491Z","comments":true,"path":"README.html","permalink":"http://www.uuuup.vip/README.html","excerpt":"","text":"LinkedList的源码分析LinkedHashMap的源码分析HashSet的源码分析HashMap的源码分析ConcurrentHashMap的源码分析ArrayList/Vector的源码分析"},{"title":"tags","date":"2018-10-22T14:35:12.633Z","updated":"2018-10-18T18:23:12.824Z","comments":true,"path":"tags/index.html","permalink":"http://www.uuuup.vip/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-10-18T18:52:16.773Z","updated":"2018-10-18T18:52:15.122Z","comments":true,"path":"about/index.html","permalink":"http://www.uuuup.vip/about/index.html","excerpt":"","text":"java程序员一枚github: https://github.com/Brooke-Paulblog: http://www.uuuup.vip/email: gentle.taoxue@gmail.com"},{"title":"categories","date":"2018-10-18T18:24:33.864Z","updated":"2018-10-18T18:24:33.858Z","comments":true,"path":"categories/index.html","permalink":"http://www.uuuup.vip/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"github更改作者的提交信息","slug":"更改github作者信息","date":"2018-12-19T23:01:34.000Z","updated":"2018-12-19T18:26:05.774Z","comments":true,"path":"2018/12/20/更改github作者信息/","link":"","permalink":"http://www.uuuup.vip/2018/12/20/更改github作者信息/","excerpt":"","text":"问题发现github拉取代码分支后提交后贡献值不增加 解决办法执行第一步：git config --global user.email &quot;youremail@googl.com&quot;git config --global user.name &quot;your name&quot; 执行第二步：git clone --bare https://github.com/user/repo.gitcd repo.git 执行第三步： filter-branch --env-filter '12345678910111213141516OLD_EMAIL=&quot;your-old-email@example.com&quot; // 你的旧的email账号CORRECT_NAME=&quot;Your Correct Name&quot; // 你的新的用户名CORRECT_EMAIL=&quot;your-correct-email@example.com&quot; // 你的新的email账号if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot; export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;fiif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot; export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi&apos; --tag-name-filter cat -- --branches --tags 执行第四步：git push --force --tags origin &#39;refs/heads/*&#39; ok，至此作者信息修改完毕 此时本地仓库提交代码会失败，首先执行 更新：git pull origin master --allow-unrelated-histories","categories":[{"name":"git filter-branch --env-filter","slug":"git-filter-branch-env-filter","permalink":"http://www.uuuup.vip/categories/git-filter-branch-env-filter/"},{"name":"collection","slug":"git-filter-branch-env-filter/collection","permalink":"http://www.uuuup.vip/categories/git-filter-branch-env-filter/collection/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.uuuup.vip/tags/git/"}]},{"title":"Java线程池的四种使用方式","slug":"Java线程池的四种使用方式","date":"2018-12-14T16:00:00.000Z","updated":"2018-12-19T16:41:24.957Z","comments":true,"path":"2018/12/15/Java线程池的四种使用方式/","link":"","permalink":"http://www.uuuup.vip/2018/12/15/Java线程池的四种使用方式/","excerpt":"","text":"Executor框架Executor 中常用的四种静态方法： 1.newSingleThreadExecutor是一个单线程的Executor，使用唯一的线程来执行任务。 2.newFixedThreadPool是一个固定长度的线程池，每当提交任务时就会创建线程，直到线程池最大数量，线程池的规模不再变化。 3.newCachedThreadPool是一个可缓存的线程池，线程池的规模不存在任何限制。 如果当前线程池的资源有空闲，那么将回收空闲资源。如果资源增加时需要线程，则向线程池添加线程。 4.newScheduledThreadPool是一个固定长度的线程池，并且以延迟的方式来执行任务。 123456789101112131415161718192021222324252627282930313233343536373839404142public class ExecutorTask &#123; public static void main(String[] args) &#123; // 1.newSingleThreadExecutor是一个单线程的Executor，使用唯一的线程来执行任务。 ExecutorService executorService1 = Executors.newSingleThreadExecutor(); executorService1.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"newSingleThreadExecutor is done\"); &#125; &#125;); executorService1.shutdown(); // 2.newFixedThreadPool是一个固定长度的线程池，每当提交任务时就会创建线程，直到线程池最大数量，线程池的规模不再变化。 ExecutorService executorService2 = Executors.newFixedThreadPool(10); executorService2.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"newFixedThreadPool is done\"); &#125; &#125;); executorService2.shutdown(); // 3.newCachedThreadPool是一个可缓存的线程池，线程池的规模不存在任何限制。 如果当前线程池的资源有空闲，那么将回收空闲资源。如果资源增加时需要线程，则向线程池添加线程。 ExecutorService executorService3 = Executors.newCachedThreadPool(); executorService3.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"newCachedThreadPool is done\"); &#125; &#125;); executorService3.shutdown(); // 4.newScheduledThreadPool是一个固定长度的线程池，并且以延迟的方式来执行任务。 ExecutorService executorService4 = Executors.newScheduledThreadPool(10); executorService4.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"newScheduledThreadPool is done\"); &#125; &#125;); executorService4.shutdown(); &#125;&#125;","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://www.uuuup.vip/tags/线程池/"}]},{"title":"FutureTask 配合 ConcurrentHashMap 使用","slug":"FutureTask使用","date":"2018-12-10T17:01:34.000Z","updated":"2018-12-10T18:45:49.069Z","comments":true,"path":"2018/12/11/FutureTask使用/","link":"","permalink":"http://www.uuuup.vip/2018/12/11/FutureTask使用/","excerpt":"","text":"FutureTask介绍FutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，直接调用其run方法或者放入线程池执行，之后可以在外部通过FutureTask的get方法异步获取执行结果。 ConcurrentHashMap 见文章 ConcurrentHashMap的源码分析本章节利用 ConcurrentHashMap 与 FutureTask 构建在多线程环境中高效的获取数据结果缓存例如： 在多线程环境中对比 通过(ConcurrentHashMap 与 FutureTask) 和 通过 Map 获取人员积分 （此处积分用随机数代替） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ValidCacheTest &#123; private static final ConcurrentHashMap&lt;String, Future&lt;Integer&gt;&gt; concurrentHashMap = new ConcurrentHashMap&lt;String, Future&lt;Integer&gt;&gt;(); private static final Map map = new HashMap(); public static void main(String[] args) throws Exception &#123; ValidCacheTest validCacheTest = new ValidCacheTest(); String personID = \"123456\"; for (int i = 0; i &lt; 5000; i++) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Object o1 = validCacheTest.compute(personID); Object o2 = validCacheTest.computeMap(personID); System.out.println(\"使用concurrentHashMap人员积分为：\" + (Integer) o1); System.out.println(\"使用map人员积分为：\" + (Integer) o2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); thread.start(); &#125; &#125; public Object compute(String personID) throws Exception &#123; Future future = concurrentHashMap.get(personID); if (future == null) &#123; Callable callable = new Callable() &#123; @Override public Object call() throws Exception &#123; // 从数据库通过人员ID获取积分，这里暂用随机数 return new Random().nextInt(1000); &#125; &#125;; FutureTask futureTask = new FutureTask(callable); //putIfAbsent在放入数据时，如果存在重复的key，那么putIfAbsent不会放入值，线程安全 future = concurrentHashMap.putIfAbsent(personID, futureTask); if (future == null) &#123; future = futureTask; futureTask.run(); &#125; &#125; return future.get(); &#125; public Object computeMap(String personID) throws Exception &#123; Object object = map.get(personID); if (object == null) &#123; Object o = new Random().nextInt(1000); //putIfAbsent在放入数据时，如果存在重复的key，那么putIfAbsent不会放入值，线程不安全 object = map.putIfAbsent(personID, o); if (object == null) &#123; object = o; &#125; &#125; return object; &#125;&#125;测试结果：（多次执行任务发现使用map时获取的值在多线程中不一致，而concurrentHashMap中获取的值不变） 使用map人员积分为：648 使用concurrentHashMap人员积分为：622 使用map人员积分为：650 使用concurrentHashMap人员积分为：622 使用map人员积分为：650 使用concurrentHashMap人员积分为：622 使用map人员积分为：650 使用concurrentHashMap人员积分为：622 使用map人员积分为：650 小结 FutureTask在高并发环境下确保任务只执行一次，配合concurrentHashMap使用，支持高并发的同时确保线程安全性。","categories":[{"name":"java 并发","slug":"java-并发","permalink":"http://www.uuuup.vip/categories/java-并发/"}],"tags":[{"name":"FutureTask","slug":"FutureTask","permalink":"http://www.uuuup.vip/tags/FutureTask/"},{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","permalink":"http://www.uuuup.vip/tags/ConcurrentHashMap/"}]},{"title":"java同步工具之CyclicBarrier","slug":"CyclicBarrier","date":"2018-12-09T16:00:00.000Z","updated":"2018-12-09T18:03:30.162Z","comments":true,"path":"2018/12/10/CyclicBarrier/","link":"","permalink":"http://www.uuuup.vip/2018/12/10/CyclicBarrier/","excerpt":"","text":"java并发之同步工具 CyclicBarrierCyclicBarrier循环屏障CyclicBarrier用于让一组线程运行并互相等待，直到共同到达一个公共屏障点 (common barrier point，又被称为同步点)，被屏障拦截的所有线程就会继续执行。 CyclicBarrier与CountDownLatch的功能非常类似。但一个CyclicBarrier实例在释放等待线程后可以继续使用。让下一批线程在屏障点等待。但CountDownLatch实例只能被使用一次。所以CyclicBarrier被称为循环 的 barrier。 CyclicBarrier类的用法构造方法 CyclicBarrier(int parties) 创建CyclicBarrier对象，parties 表示屏障拦截的线程数量。 CyclicBarrier(int parties, Runnable barrierAction) 创建 CyclicBarrier对象，该构造方法提供了一个Runnable参数，在一组线程中的最后一个线程到达之后，执行Runnable中的程序，再之后释放正在等待的线程。Runnable在屏障点上只运行一次。 方法 int await() 通知CyclicBarrier实例，当前线程已经到达屏障点，然后当前线程将被阻塞。 int await(long timeout, TimeUnit unit)指定当前线程被阻塞的时间。 int getNumberWaiting()返回当前在屏障处等待的线程数。 int getParties()返回CyclicBarrier的需要拦截的线程数。 boolean isBroken() 查询此屏障是否处于损坏状态。 void reset() 将屏障重置为其初始状态。 例如：所有的线程都到达共同屏障点后执行数据，可以用于分类数据求总和12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; int parties = 5; CyclicBarrier cyclicBarrier = new CyclicBarrier(parties, new Runnable() &#123; @Override public void run() &#123; System.out.println(currentThread().getName() + \"所有线程执行完毕，结束\"); &#125; &#125;); for (int i = 0; i &lt; parties; i++) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(currentThread().getName() + \"准备执行\"); try &#123; Thread.sleep(1000); System.out.println(currentThread().getName() + \" 开始执行，等待别的线程执行完毕\"); cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(currentThread().getName() + \" 执行完毕，等待别的线程执行完毕\"); &#125; &#125; &#125;); thread.start(); &#125; &#125;运行结果：Thread-0准备执行Thread-4准备执行Thread-1准备执行Thread-3准备执行Thread-2准备执行Thread-4 开始执行，等待别的线程执行完毕Thread-3 开始执行，等待别的线程执行完毕Thread-0 开始执行，等待别的线程执行完毕Thread-2 开始执行，等待别的线程执行完毕Thread-1 开始执行，等待别的线程执行完毕Thread-3所有线程执行完毕，结束Thread-3 执行完毕，等待别的线程执行完毕Thread-0 执行完毕，等待别的线程执行完毕Thread-4 执行完毕，等待别的线程执行完毕Thread-1 执行完毕，等待别的线程执行完毕Thread-2 执行完毕，等待别的线程执行完毕","categories":[{"name":"java 并发","slug":"java-并发","permalink":"http://www.uuuup.vip/categories/java-并发/"}],"tags":[{"name":"CyclicBarrier","slug":"CyclicBarrier","permalink":"http://www.uuuup.vip/tags/CyclicBarrier/"}]},{"title":"java同步工具之Semaphore","slug":"Semaphore","date":"2018-12-06T16:00:00.000Z","updated":"2018-12-09T13:57:36.859Z","comments":true,"path":"2018/12/07/Semaphore/","link":"","permalink":"http://www.uuuup.vip/2018/12/07/Semaphore/","excerpt":"","text":"java并发之同步工具 SemaphoreSemaphore信号量Semaphore 用于控制线程并发数，Semaphore 可以控制同时访问资源的线程个数，实现一个文件允许访问的并发数。Semaphore维护了一个许可集，当调用acquire() 方法获取到许可时即可进入，无法获取许可的线程阻塞到有许可（或者直到连接中断或者连接超时）。而 release() 表示释放一个许可。可以把Semaphore看成是一种共享锁。Semaphore允许同一时间多个线程同时访问临界区。 Semaphore类的用法常用方法：public void acquire() 获取许可。 public boolean tryAcquire() 尝试获取许可。 public boolean tryAcquire(long timeout, TimeUnit unit) 在指定的时间内尝试地获取1个许可。 public void release() 释放许可。该方法一般调用于finally块中。int availablePermits() 返回此信号量中当前可用的许可数。 例如： 在多线程中展示信号量的可用许可，为了准确测试当前许可数量，需要同步锁住semaphore 对象进行测试。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class SemaphoreDemo &#123; public static void main(String[] args) &#123; int permits = 4; Semaphore semaphore = new Semaphore(permits); for (int i = 0; i &lt; permits; i++) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; synchronized (semaphore) &#123; try &#123; System.out.println(\"当前可用许可 \" + (semaphore.availablePermits())); semaphore.acquire(); super.run(); System.out.println(currentThread().getName() + \" 获取一个许可\"); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(\"当前可用许可 \" + (semaphore.availablePermits())); System.out.println(currentThread().getName() + \" 释放一个许可\"); semaphore.release(); System.out.println(\"当前可用许可 \" + (semaphore.availablePermits())); &#125; &#125; &#125; &#125;; thread.start(); &#125; &#125;&#125;输出结果：当前可用许可 4Thread-0 获取一个许可当前可用许可 3Thread-0 释放一个许可当前可用许可 4Thread-3 获取一个许可当前可用许可 3Thread-3 释放一个许可当前可用许可 4Thread-2 获取一个许可当前可用许可 3Thread-2 释放一个许可当前可用许可 4Thread-1 获取一个许可当前可用许可 3Thread-1 释放一个许可","categories":[{"name":"java 并发","slug":"java-并发","permalink":"http://www.uuuup.vip/categories/java-并发/"}],"tags":[{"name":"Semaphore","slug":"Semaphore","permalink":"http://www.uuuup.vip/tags/Semaphore/"}]},{"title":"java同步工具之CountDownLatch","slug":"CountDownLatch","date":"2018-12-06T16:00:00.000Z","updated":"2018-12-09T14:04:05.357Z","comments":true,"path":"2018/12/07/CountDownLatch/","link":"","permalink":"http://www.uuuup.vip/2018/12/07/CountDownLatch/","excerpt":"","text":"java并发之同步工具 CountDownLatchCountDownLatch 概念CountDownLatch 是一种灵活的闭锁实现，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器初始化为一个正整数，表示需要等待的事件数量。countDown 方法递减计数器，表示事件发生。而await方法等待计数器达到零，这表示所有需要等待的事件都已经发生，可以执行自定义的操作。如果计数器的值非零，那么await会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。 CountDownLatch类的用法构造方法：CountDownLatch(int count) 构造方法参数指定了计数的次数。 方法：void await() 使当前线程在锁存器倒计数至0之前一直等待，除非线程被中断。boolean await(long timeout, TimeUnit unit) 使当前线程在锁存器倒计数至0之前一直等待，除非线程被中断或超出了指定的等待时间。void countDown() 计数减1。当计数为0，则释放所有等待的线程。long getCount() 返回当前计数。String toString() 返回标识此锁存器及其状态的字符串。 例如：使用了两个闭锁，分别表示起始门和结束门，当起始门的值为零时触发结束门的countDown，能使主线程高效的等待所有工作执行完成。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; int nThreads = 5; CountDownLatch countDownLatchStart = new CountDownLatch(1); CountDownLatch countDownLatchEnd = new CountDownLatch(nThreads); for (int i = 0; i &lt; nThreads; i++) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; synchronized (countDownLatchEnd) &#123; try &#123; System.out.println(currentThread().getName() + \" countDownLatchStart start...\"); super.run(); countDownLatchStart.await(); System.out.println(currentThread().getName() + \" countDownLatchStart end...\"); &#125; catch (Exception e) &#123; &#125; finally &#123; countDownLatchEnd.countDown(); System.out.println(\"current countDown count is...\" + countDownLatchEnd.getCount()); &#125; &#125; &#125; &#125;; thread.start(); &#125; long startTime = System.currentTimeMillis(); countDownLatchStart.countDown(); countDownLatchEnd.await(); long endTime = System.currentTimeMillis(); System.out.println(\"countDownLatchEnd end...cost(\" + (endTime - startTime) + \")\"); &#125;&#125;//运行结果：Thread-0 countDownLatchStart start...Thread-0 countDownLatchStart end...current countDown count is...4Thread-4 countDownLatchStart start...Thread-4 countDownLatchStart end...current countDown count is...3Thread-3 countDownLatchStart start...Thread-3 countDownLatchStart end...current countDown count is...2Thread-2 countDownLatchStart start...Thread-2 countDownLatchStart end...current countDown count is...1Thread-1 countDownLatchStart start...Thread-1 countDownLatchStart end...current countDown count is...0countDownLatchEnd end...cost(2) CountDownLatch的不足CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。","categories":[{"name":"java 并发","slug":"java-并发","permalink":"http://www.uuuup.vip/categories/java-并发/"}],"tags":[{"name":"CountDownLatch","slug":"CountDownLatch","permalink":"http://www.uuuup.vip/tags/CountDownLatch/"}]},{"title":"Volatile关键字解析","slug":"Volatile","date":"2018-11-28T16:00:00.000Z","updated":"2018-12-09T14:09:38.011Z","comments":true,"path":"2018/11/29/Volatile/","link":"","permalink":"http://www.uuuup.vip/2018/11/29/Volatile/","excerpt":"","text":"前言 在介绍Volatile之前，先简单了解一下java内存模型。在java内存模型中规定，简称为JMM。 主内存和工作内存主内存存放数据共享的区域，数据可以在线程中共享，包括实例变量，静态变量等。线程在工作时，需要将主存中的数据拷贝到工作内存，线程之间的数据不可以共享，并且不能直接操作主内存或者其他线程工作内存中的数据。这里所提到的主内存可以简单认为是堆内存，而工作内存可以简单认为是栈内存。 工作内存每个线程有自己的工作内存，各个线程之间不支持数据资源共享，线程使用的变量是从主内存的副本拷贝，线程所有的数据操作必须在工作内存中，无法直接获取主内存的数据，线程之间的变量值传递必须通过主内存来完成。 Volatile 原理 Java语言提供了一种稍弱的同步机制，即volatile变量，确保变量的更新操作通知到其他线程。当线程变量被volatile修饰后，编译器会自动识别该变量属于线程共享，因此在读取volatile修饰的变量时总是读取最新的值。 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 内存可见性 变量在被volatile修饰后更改变量的值会立即被写回主存，同时会使其他线程工作内存的旧值失效，新值对于其他线程是可见的，因为volatile修饰的变量在每个线程中使用前都会去主内存中获取最新的值。 虽然volatile修饰的值每次都会被线程获取到，但是并不能保证线程并发的安全性。因为忽略了原子性，volatile在执行时并不能保证原子性，对变量的操作可能就是很简单的 i+=1,但是底层需要多条字节码操作才能完成，在并发情况并不能保证原子性。 禁止指令重排序优化 指令重排序是指CPU在正确处理指令依赖(数据依赖)并且保障程序执行得到正确结果的情况下，调整代码的执行顺序，允许将多条指令不按照程序规定顺序分开发送给各相应电路单元处理。需要注意的是指令重排序不会影响到代码在单线程环境下的执行，会影响到多线程并发情况下执行的正确性。 使用条件如果让volatile保证原子性，必须符合以下两条规则：1.运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；2.变量不需要与其他的状态变量共同参与不变约束；","categories":[{"name":"java","slug":"java","permalink":"http://www.uuuup.vip/categories/java/"}],"tags":[{"name":"Volatile","slug":"Volatile","permalink":"http://www.uuuup.vip/tags/Volatile/"}]},{"title":"线程与进程详解","slug":"线程与进程详解","date":"2018-10-22T23:01:34.000Z","updated":"2018-10-23T13:41:46.000Z","comments":true,"path":"2018/10/23/线程与进程详解/","link":"","permalink":"http://www.uuuup.vip/2018/10/23/线程与进程详解/","excerpt":"","text":"进程的定义 进程是指处于运行过程中的程序，并且具有一定的独立功能。进程是系统进行资源分配和调度的一个单位。 当程序进入内存运行时，即为进程。几乎所有的操作系统都支持多任务运行，而每个任务就是一个进程。 当一个进程运行时，内部可以支持多个执行流程，而每个流程就是一个线程。 线程的定义线程的介绍线程也称为轻型进程，因为线程只能在单个进程的作用域中使用，所以创建线程比创建进程要廉价得多。 线程是进程的组成部分，一个进程可以拥有多个线程，而一个线程只能属于单个进程。线程有自己的独立资源，比如栈，程序计数器，寄存器。 线程可以与当前进程中的其他线程共享进程资源。 线程的特点线程之间可以协作完成任务。 线程之间是独立运行的，相互之间互不影响。 线程之间执行属于抢占式的，也就是说，线程的执行顺序是不一致的。 线程之间可以并发执行。 多线程的实现方式三种实现方式包括继承Thread， 实现Runnable, 使用ExecutorService、Callable、Future实现有返回结果的多线程。 1234567891011121314151617181920212223242526272829303132public class ThreadTest extends Thread &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i ++) &#123; System.out.println(\"Thread,线程:::\" + Thread.currentThread().getName() + \" 正在执行\"); &#125; &#125;&#125;class RunnableTest implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i ++) &#123; System.out.println(\"Runnable,线程:::\" + Thread.currentThread().getName() + \" 正在执行\"); &#125; &#125;&#125;class CallableDemo implements Callable &#123; @Override public Object call() throws Exception &#123; for (int i = 0; i &lt; 5; i ++) &#123; System.out.println(\"Callable,线程:::\" + Thread.currentThread().getName() + \" 正在执行\"); &#125; return \"Callable,线程:::\" + Thread.currentThread().getName() + \" 正在执行\"; &#125;&#125; 第一种继承Thread类1234ThreadTest threadTest = new ThreadTest();threadTest.start();ThreadTest threadTest1 = new ThreadTest();threadTest1.start(); 继承Thread的运行结果 12345678910Thread,线程:::Thread-0 正在执行Thread,线程:::Thread-1 正在执行Thread,线程:::Thread-0 正在执行Thread,线程:::Thread-1 正在执行Thread,线程:::Thread-0 正在执行Thread,线程:::Thread-1 正在执行Thread,线程:::Thread-0 正在执行Thread,线程:::Thread-0 正在执行Thread,线程:::Thread-1 正在执行Thread,线程:::Thread-1 正在执行 第二种实现Runnable接口123456//实现多线程RunnableTest runnableTest = new RunnableTest();Thread threadTest2 = new Thread(runnableTest);Thread threadTest3 = new Thread(runnableTest);threadTest2.start();threadTest3.start(); 实现Runnable接口的运行结果 12345678910Runnable,线程:::Thread-0 正在执行Runnable,线程:::Thread-1 正在执行Runnable,线程:::Thread-0 正在执行Runnable,线程:::Thread-1 正在执行Runnable,线程:::Thread-0 正在执行Runnable,线程:::Thread-1 正在执行Runnable,线程:::Thread-0 正在执行Runnable,线程:::Thread-1 正在执行Runnable,线程:::Thread-0 正在执行Runnable,线程:::Thread-1 正在执行 第三种使用ExecutorService、Callable、Future实现有返回结果的多线程12345678ExecutorService executorService = Executors.newFixedThreadPool(2); CallableDemo callableDemo1 = new CallableDemo(); CallableDemo callableDemo2 = new CallableDemo(); Future future1 = executorService.submit(callableDemo1); Future future2 = executorService.submit(callableDemo2); future1.get(); //如果调用返回Future对象的get()方法，会阻塞直到计算完成 future2.get(); executorService.shutdown(); 使用ExecutorService、Callable、Future 的运行结果 12345678910Callable,线程:::pool-1-thread-2 正在执行Callable,线程:::pool-1-thread-1 正在执行Callable,线程:::pool-1-thread-1 正在执行Callable,线程:::pool-1-thread-1 正在执行Callable,线程:::pool-1-thread-1 正在执行Callable,线程:::pool-1-thread-2 正在执行Callable,线程:::pool-1-thread-1 正在执行Callable,线程:::pool-1-thread-2 正在执行Callable,线程:::pool-1-thread-2 正在执行Callable,线程:::pool-1-thread-2 正在执行","categories":[{"name":"多线程","slug":"多线程","permalink":"http://www.uuuup.vip/categories/多线程/"}],"tags":[{"name":"进程","slug":"进程","permalink":"http://www.uuuup.vip/tags/进程/"},{"name":"线程","slug":"线程","permalink":"http://www.uuuup.vip/tags/线程/"}]},{"title":"LinkedList的源码分析","slug":"LinkedList","date":"2018-09-15T23:01:34.000Z","updated":"2018-12-09T14:08:29.360Z","comments":true,"path":"2018/09/16/LinkedList/","link":"","permalink":"http://www.uuuup.vip/2018/09/16/LinkedList/","excerpt":"","text":"LinkedList 简介LinkedList 是继承于AbstractSequentialList的双向链表， 它可以被当做堆栈，队列或双端队列使用。LinkedList 实现了List接口， 能对它进行队列操作。LinkedList 实现了Cloneable接口， 覆盖了函数clone(), 支持克隆。LinkedList 实现了Deque接口， 能将 LinkedList当做双端队列使用。LinkedList 实现了Serializable接口，意味着支持序列化， 便于在网络中传输和保存。 12345public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; &#125; LinkedList 是采用链表的方式来实现List接口的,它本身有自己特定的方法， 如: addFirst(),addLast(),getFirst(),getLast(),removeFirst()，removeFirst()，removeLast()。 元素的插入与获取addFirst() 和 addLast()直接插入头部元素 和 尾部元素实现方式1234567891011121314151617181920212223242526272829public void addFirst(E e) &#123; linkFirst(e);&#125;private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //构造头部对象 first = newNode; if (f == null) //如果f为空，则first == last last = newNode; else f.prev = newNode; //否则 头节点为newNode size++; modCount++;&#125;public void addLast(E e) &#123; linkLast(e); &#125;//默认的添加方式也是由此方法实现 void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //构造尾部对象 last = newNode; if (l == null) //如果l为空，则first == last first = newNode; else l.next = newNode; //否则，尾节点为newNode size++; modCount++;&#125; getFirst() 和 getLast()直接获取头部元素 和 尾部元素实现方式123456789101112public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125; public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; LinkedList 查找元素 1234567891011121314151617181920public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; //判断index 是否为 list size 的 一半 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) // 从 0 ~ index 中循环遍历 x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) // 从 index ~ zize - 1 中遍历 x = x.prev; return x; &#125;&#125; 由此得出结论： LinkedList 采用了链表结构，所以在添加和删除方面效率高，查找比较慢 元素的删除removeFirst() 和 removeLast()LinkedList 移除首个元素 和 移除最后一个元素123456789101112131415161718192021222324252627282930313233//removeFirst 主要实现private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; //将当前元素清空 f.next = null; // help GC first = next; //指针后移 if (next == null) last = null; else next.prev = null; //将节点prev置空 size--; modCount++; return element;&#125;//removeLast 主要实现private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; //将当前元素清空 l.prev = null; // help GC last = prev; //指针前移 if (prev == null) first = null; else prev.next = null; //将节点next置空 size--; modCount++; return element;&#125; 主要移除元素底层实现(根据下标移除，根据元素移除)链表结构图如下：将链表重新组装12345678910111213141516171819202122232425E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; //获取当前节点下一节点 final Node&lt;E&gt; prev = x.prev; //获取当前节点上一节点 if (prev == null) &#123; //如果上一节点为空，则首节点下一节点 first = next; &#125; else &#123; //将上一节点的下一节点替换为当前元素的下一节点 prev.next = next; x.prev = null; &#125; if (next == null) &#123; //如果下一节点为空，则尾节点上一节点 last = prev; &#125; else &#123; //将下一节点的上一节点替换为当前元素的下一节点 next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; LinkedList 用作堆栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * LinkedList 实现堆栈的先进后出 */public class StackDemo &#123; private LinkedList linkedList = new LinkedList&lt;&gt;(); /** * 将每次添加的元素都添加到第一个位置 * * @param o */ public void push(Object o) &#123; linkedList.addFirst(o); &#125; /** * 取出第一个元素但是不删除元素 * * @return */ public Object peek() &#123; return linkedList.peek(); &#125; /** * 取出并移除元素 * * @return */ public Object poll() &#123; return linkedList.poll(); &#125; /** * 获取元素个数 * * @return */ public int size() &#123; return linkedList.size(); &#125; /** * 判断堆栈是否为空 * (即判断 linkedList是否为空) * * @return */ public boolean isEmpty() &#123; return linkedList.isEmpty(); &#125; public static void main(String[] args) &#123; StackDemo stackDemo = new StackDemo(); stackDemo.push(\"1\"); stackDemo.push(\"2\"); stackDemo.push(\"3\"); stackDemo.push(\"4\"); stackDemo.push(\"5\"); System.out.println(\"取出第一个元素：：：：\" + stackDemo.peek()); System.out.println(\"取出第一个元素：：：：\" + stackDemo.poll()); while (!stackDemo.isEmpty()) &#123; System.out.print(stackDemo.poll()); &#125; &#125;&#125; LinkedList 用作堆栈 输出结果为1234567891011插入第1个元素,值为 1插入第2个元素,值为 2插入第3个元素,值为 3插入第4个元素,值为 4插入第5个元素,值为 5取出第一个元素 5取出第一个元素 5输出顺序为 4输出顺序为 3输出顺序为 2输出顺序为 1 LinkedList 用作队列123456789101112131415161718192021/** * LinkedList 实现先进先出队列 */public class QueueDemo &#123; public static void main(String[] args) &#123; Queue queue = new LinkedList(); //offer()方法是往队列尾部加入元素 for (int i = 0; i &lt; 5; i++) &#123; queue.offer(i + 1); System.out.println(\"插入第\"+ (i + 1) +\"个元素,\" + \"值为 \" + (i + 1)); &#125; while (!queue.isEmpty()) &#123; System.out.println(\"输出顺序 \" + queue.poll()); &#125; &#125;&#125; 输出结果为12345678910插入第1个元素,值为 1插入第2个元素,值为 2插入第3个元素,值为 3插入第4个元素,值为 4插入第5个元素,值为 5输出顺序 1输出顺序 2输出顺序 3输出顺序 4输出顺序 5","categories":[{"name":"JAVA 集合","slug":"JAVA-集合","permalink":"http://www.uuuup.vip/categories/JAVA-集合/"}],"tags":[{"name":"LinkedList","slug":"LinkedList","permalink":"http://www.uuuup.vip/tags/LinkedList/"}]},{"title":"LinkedHashMap的源码分析","slug":"LinkedHashMap","date":"2018-09-14T23:01:34.000Z","updated":"2018-12-09T14:08:29.345Z","comments":true,"path":"2018/09/15/LinkedHashMap/","link":"","permalink":"http://www.uuuup.vip/2018/09/15/LinkedHashMap/","excerpt":"","text":"LinkedHashMap 简介 LinkedHashMap 继承了 HashMap, 实现了map接口。 所以 LinkedHashMap 包含了 HashMap 的所有功能， 它是一个关联数组，线程不安全，并且key值，value值允许为空。LinkedHashMap 与 HashMap 不同之处是它支持写入顺序排序，访问顺序排序。 顺序展示效果示例代码 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Map map = new LinkedHashMap(); map.put(\"1\", 1); map.put(\"2\", 2); map.put(\"3\", 3); map.put(\"4\", 4); map.put(\"5\", 5); Iterator iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); System.out.println(entry.getKey() + \"::\" + entry.getValue()); &#125; System.out.println(\"accessOrder 设置为 true\"); Map mapOrder = new LinkedHashMap(15, 0.75f, true); mapOrder.put(\"1\", 1); mapOrder.put(\"2\", 2); mapOrder.put(\"3\", 3); mapOrder.put(\"4\", 4); mapOrder.put(\"5\", 5); mapOrder.get(\"1\"); Iterator iterator1 = mapOrder.entrySet().iterator(); while (iterator1.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator1.next(); System.out.println(entry.getKey() + \"::\" + entry.getValue()); &#125;&#125;返回的结果如下： 写入顺序排序1::12::23::34::45::5accessOrder 设置为 true访问顺序排序2::23::34::45::51::1 带着疑问剖析源码，LinkedHashMap的构造函数有五种：123456789101112131415161718192021222324252627282930//默认是false，则迭代时输出的顺序是插入节点的顺序。若为true，则输出的顺序是按照访问节点的顺序。final boolean accessOrder;//指定初始化时的容量，和扩容的加载因子public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false;&#125;//指定初始化时的容量public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125;public LinkedHashMap() &#123; super(); accessOrder = false;&#125;//利用另一个Map 来构建public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; super(); accessOrder = false; putMapEntries(m, false);&#125;//指定初始化时的容量，和扩容的加载因子，以及迭代输出节点的顺序public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 构造函数和HashMap相比，就是增加了一个accessOrder参数。用于控制迭代时的节点顺序。 LinkedHashMap的添加在LinkedHashMap中没有重写HashMap的put方法，但是重写了HashMap中的newNode 方法，在每次构建新节点时，通过linkNodeLast(p)，将新节点链接在内部双向链表的尾部。源码如下：123456789101112131415161718Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; //在构建新节点时，构建的是`LinkedHashMap.Entry` 不再是`Node`. LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125;//每次插入数据是插入到尾节点，并且把方插入的节点的before设置为lastprivate void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; LinkedHashMap的删除LinkedHashMap也没有重写remove()方法，因为它的删除逻辑和HashMap并无区别。重点在于LinkedHashMap 重写了 afterNodeRemoval方法。12345678910111213void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null;//待删除节点 p 的前置后置节点都置空 if (b == null) head = a; else b.after = a; //重新关联b的after节点 if (a == null) tail = b; else a.before = b; //重新关联a的before节点 &#125; LinkedHashMap的查找LinkedHashMap 重写了 get() 和 getOrDefault() 方法。对比HashMap的实现可以发现只是增加了在成员变量(构造函数时赋值)accessOrder = true 的情况下会调用 afterNodeAccess() 方法。1234567891011121314151617181920212223242526272829303132333435363738394041public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125;public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return defaultValue; if (accessOrder) afterNodeAccess(e); return e.value;&#125;//此方法的目的是将不是尾部的元素并且accessOrder = true的节点e移动至内部的双向链表的尾部void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; //将p的设置为尾节点 if (b == null) // 如果p的前置节点为null，则p以前是头节点，所以更新现在的头节点为p的后置节点a head = a; else //否则更新b的后置节点为a b.after = a; if (a != null) // 如果p的后置节点不为null， 则更新a的前置节点为b a.before = b; else // 如果p的后置节点为null，则p就是尾节点，更新last 引用为b last = b; if (last == null) //如果尾节点为空，则链表中只有一个节点 head = p; else &#123; // 否则更新更新p的前置节点为原尾节点last，last的后置节点为p p.before = last; last.after = p; &#125; tail = p;//尾节点的引用赋值成p ++modCount; &#125;&#125;","categories":[{"name":"JAVA 集合","slug":"JAVA-集合","permalink":"http://www.uuuup.vip/categories/JAVA-集合/"}],"tags":[{"name":"LinkedHashMap","slug":"LinkedHashMap","permalink":"http://www.uuuup.vip/tags/LinkedHashMap/"}]},{"title":"HashSet的源码分析","slug":"HashSet","date":"2018-09-13T23:01:34.000Z","updated":"2018-12-09T14:08:29.357Z","comments":true,"path":"2018/09/14/HashSet/","link":"","permalink":"http://www.uuuup.vip/2018/09/14/HashSet/","excerpt":"","text":"HashSet 简介HashSet 是一个没有重复元素的集合。它是由 HashMap 实现的， 无序且允许空值。HashSet 是非线程同步的，没有提供数据访问保护，在多线程环境中容易导致多个线程更改数据后造成数据脏读。 HashSet 的添加方法12345678//map是一个HashMap&lt;E, Object&gt;对象，HashSet是由一个HashMap实例支持的private transient HashMap&lt;E,Object&gt; map;//PRESENT是一个static final Object对象，用来作为HashMap中的value值。private static final Object PRESENT = new Object();//熟悉hashmap的实现方式的话很容易理解put方法，对象作为key值，不允许重复，value使用 PRESENT。 public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; HashSet 的查找方法1234//如果此set包含指定元素，则返回 truepublic boolean contains(Object o) &#123; return map.containsKey(o);&#125; HashSet 的清空与移除方法 123456789//如果指定元素存在于此set中，则将其移除public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125;//从此set中移除所有元素public void clear() &#123; map.clear();&#125; HashSet 的遍历方式12345678910Set set = new HashSet();set.add(\"!\");set.add(\"a\");set.add(\"1\");Iterator iterator = set.iterator();//通过keyset的方式获取key值集合的迭代器while (iterator.hasNext()) &#123; String key = (String) iterator.next(); System.out.println(key);&#125;","categories":[{"name":"JAVA 集合","slug":"JAVA-集合","permalink":"http://www.uuuup.vip/categories/JAVA-集合/"},{"name":"collection","slug":"JAVA-集合/collection","permalink":"http://www.uuuup.vip/categories/JAVA-集合/collection/"}],"tags":[{"name":"HashSet","slug":"HashSet","permalink":"http://www.uuuup.vip/tags/HashSet/"}]},{"title":"HashMap的源码分析","slug":"HashMap","date":"2018-09-12T23:01:34.000Z","updated":"2018-12-09T14:08:29.351Z","comments":true,"path":"2018/09/13/HashMap/","link":"","permalink":"http://www.uuuup.vip/2018/09/13/HashMap/","excerpt":"","text":"HashMap 简介HashMap 是一个散列表， 它存储的内容是键值对（key - value）映射。HashMap 继承于 AbstractMap， 实现了Map， Cloneable，Serializable 接口。HashMap 不是线程安全的， 不适用于多线程中， 此外，HashMap中的映射不是有序的。HashMap 里面是一个数组，然后数组中每个元素是一个单项链表。图中Entry 包含四个属性，key，value，hash 值和用于单项链表的next。 重要参数capacity 和 loadFactor。capacity 当前数组容量，始终保持 2^n，默认值为 1&lt;&lt;4，最大为 1&lt;&lt;16, 可以扩容，扩容后数组大小为当前的 2 倍。loadFactor 负载因子，默认为 0.75。threshold 扩容的阈值，等于 capacity * loadFactor。123static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f; HashMap 的 put 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;//第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置 else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //首先，判断该位置的第一个数据和我们要插入的数据，key 是不是\"相等\"，如果是，取出这个节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 如果该节点是代表红黑树的节点，调用红黑树的插值方法 else &#123; // 到这里，说明数组该位置上是一个链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个 // 会触发下面的 treeifyBin，也就是将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // e!=null 说明存在旧值的key与要插入的key\"相等\" // 对于我们分析的put操作，下面这个 if 其实就是进行 \"值覆盖\"，然后返回旧值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125;接下来看 hashmap 的 resize 方法final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候 newCap = oldThr; else &#123; // 对应使用 new HashMap() 初始化后，第一次 put 的时候 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 用新的数组大小初始化新的数组 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; HashMap 的 get方法1.计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)2.判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步3.判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步4.遍历链表，直到找到相等(==或equals)的 key 1234567891011121314151617181920212223public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; 1 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) 2 return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) 3 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; 4 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125;","categories":[{"name":"JAVA 集合","slug":"JAVA-集合","permalink":"http://www.uuuup.vip/categories/JAVA-集合/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://www.uuuup.vip/tags/HashMap/"}]},{"title":"ConcurrentHashMap的源码分析","slug":"ConcurrentHashMap","date":"2018-09-11T23:01:34.000Z","updated":"2018-12-09T14:08:29.354Z","comments":true,"path":"2018/09/12/ConcurrentHashMap/","link":"","permalink":"http://www.uuuup.vip/2018/09/12/ConcurrentHashMap/","excerpt":"","text":"ConcurrentHashMap 简介 正是由于HashMap 不是线程安全的，所以大佬给我们带来了 线程安全的ConcurrentHashMap。 本文的分析的源码是JDK8的版本，与JDK7的版本有很大的差异，java7中 ConcurrentHashMap 由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。 它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用CAS算法。它沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想， 但是为了做到并发，又增加了很多辅助的类，例如TreeBin，Traverser等对象内部类。123456789101112131415161718192021222324252627282930hashmap 的 Node 类static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125;&#125;concurrentHashMap 的 Node 类static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next; Node(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.val = val; this.next = next; &#125;&#125; 其中的concurrentHashMap的 val next 都用了 volatile 修饰，保证了元素可见性。 concurrentHashMap的添加方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); (1). 根据 key 计算出 hashcode 。 int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) (2). 判断是否需要进行初始化。 tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; (3). 根据key的hash值和容器的容量减一后进行与运算定位。如果为空就尝试使用cas插入数据 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED) (4). 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。 tab = helpTransfer(tab, f); else &#123; V oldVal = null; synchronized (f) &#123; (5). 如果都不满足，则利用 synchronized 锁写入数据。 if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; //链表节点 binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; //树节点，与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode. Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); (6). 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。 if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null;&#125; concurrentHashMap 定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。 12345678910111213141516@SuppressWarnings(\"unchecked\")此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125;此函数用于比较tab数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123; return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125;利用volatile方法设置节点位置的值static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123; U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);&#125; concurrentHashMap的获取方法12345678910111213141516171819public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; (1). 根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。 if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) (2). 如果是红黑树那就按照树的方式获取值。 return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123; (3). 都不满足那就按照链表的方式遍历获取值。 if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null; &#125;","categories":[{"name":"JAVA 集合","slug":"JAVA-集合","permalink":"http://www.uuuup.vip/categories/JAVA-集合/"}],"tags":[{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","permalink":"http://www.uuuup.vip/tags/ConcurrentHashMap/"}]},{"title":"ArrayList/Vector的源码分析","slug":"ArrayList","date":"2018-09-11T09:01:34.000Z","updated":"2018-12-09T14:08:29.364Z","comments":true,"path":"2018/09/11/ArrayList/","link":"","permalink":"http://www.uuuup.vip/2018/09/11/ArrayList/","excerpt":"","text":"ArrayListArrayList 是动态数组，其实就是Array的复杂版本，它提供了动态增加和减少元素的功能，实现了List，RandomAccess, Collection接口，ArrayList不是线程安全的，建议在单线程中使用ArrayList。 ArrayList 包含两个重要属性分别是： 12345678910/*** elementData；* transient 关键字修饰表示防止此字段被序列化* 避免了浪费资源去存储没有的数据* size:* elementData中已存放的元素的个数，注意：不是elementData的容量* */transient Object[] elementData;private int size; 因为 elementData无法被序列化， 所以ArrayList 的序列化和反序列化依赖writeObject 和 readObject方法来实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; /** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 往ArrayList 中添加元素单个元素有两种方式第一种：将单个元素添加到尾部，并将size + 1。123456789101112131415161718192021222324/** * 向elementData中添加元素 */public boolean add(E var1) &#123; this.ensureCapacityInternal(this.size + 1);//确保对象数组elementData有足够的容量，可以将新加入的元素e加进去 this.elementData[this.size++] = var1;//加入新元素e，size加1 return true;&#125;/** * 确保数组的容量足够存放新加入的元素，若不够，要扩容 */public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length;//获取数组大小（即数组的容量） //当数组满了，又有新元素加入的时候，执行扩容逻辑 if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3) / 2 + 1;//新容量为旧容量的1.5倍+1 if (newCapacity &lt; minCapacity)//如果扩容后的新容量还是没有传入的所需的最小容量大或等于（主要发生在addAll(Collection&lt;? extends E&gt; c)中） newCapacity = minCapacity;//新容量设为最小容量 elementData = Arrays.copyOf(elementData, newCapacity);//复制新容量 &#125;&#125; 第二种：将单个元素添加到指定位置。12345678910public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1);//确保对象数组elementData有足够的容量，可以将新加入的元素e加进去 System.arraycopy(elementData, index, elementData, index + 1, size - index);//复制数组，将值往后移动 elementData[index] = element; size++;&#125; 12345678910/*** 添加元素时判断elementData是否为空，为空则设置elementData的大小为10*/private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; 由此可见两种添加方式前者比后者节省资源消耗。 VectorVector 也是实现于List接口，底层数据结构和ArrayList类似，也是动态数组存放数据，不过是在 add() 方法的时候使用 synchronized 进行同步写数据，与ArrayList不同的是Vector 线程安全，但是开销较大，所以 Vector 是一个同步容器并不是一个并发容器。 123456789101112131415161718192021222324/*** 在对象数组中尾部添加单个元素和在指定位置添加单个元素* 使用synchronized 进行同步写数据*/public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;public void add(int index, E element) &#123; insertElementAt(element, index);&#125;public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt; \" + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++;&#125;","categories":[{"name":"JAVA 集合","slug":"JAVA-集合","permalink":"http://www.uuuup.vip/categories/JAVA-集合/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"http://www.uuuup.vip/tags/ArrayList/"},{"name":"Vector","slug":"Vector","permalink":"http://www.uuuup.vip/tags/Vector/"}]}]}