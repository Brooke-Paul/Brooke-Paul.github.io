{"meta":{"title":"Brooke-Paul","subtitle":"record my daily life","description":"No accumulation of thousands of miles","author":"Brooke-Paul","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"文章标题","slug":"文章标题","date":"2018-10-16T16:58:41.000Z","updated":"2018-10-16T16:58:41.978Z","comments":true,"path":"2018/10/17/文章标题/","link":"","permalink":"http://yoursite.com/2018/10/17/文章标题/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"ArrayList","date":"2018-10-15T16:47:13.076Z","updated":"2018-10-15T16:47:13.076Z","comments":true,"path":"2018/10/16/ArrayList/","link":"","permalink":"http://yoursite.com/2018/10/16/ArrayList/","excerpt":"","text":"ArrayList/Vector 的源码分析ArrayListArrayList 是动态数组，其实就是Array的复杂版本，它提供了动态增加和减少元素的功能，实现了List，RandomAccess, Collection接口，ArrayList不是线程安全的，建议在单线程中使用ArrayList。 ArrayList 包含两个重要属性分别是： 12345678910/*** elementData；* transient 关键字修饰表示防止此字段被序列化* 避免了浪费资源去存储没有的数据* size:* elementData中已存放的元素的个数，注意：不是elementData的容量* */transient Object[] elementData;private int size; 因为 elementData无法被序列化， 所以ArrayList 的序列化和反序列化依赖writeObject 和 readObject方法来实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; /** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 往ArrayList 中添加元素单个元素有两种方式第一种：将单个元素添加到尾部，并将size + 1。123456789101112131415161718192021222324/** * 向elementData中添加元素 */public boolean add(E var1) &#123; this.ensureCapacityInternal(this.size + 1);//确保对象数组elementData有足够的容量，可以将新加入的元素e加进去 this.elementData[this.size++] = var1;//加入新元素e，size加1 return true;&#125;/** * 确保数组的容量足够存放新加入的元素，若不够，要扩容 */public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length;//获取数组大小（即数组的容量） //当数组满了，又有新元素加入的时候，执行扩容逻辑 if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3) / 2 + 1;//新容量为旧容量的1.5倍+1 if (newCapacity &lt; minCapacity)//如果扩容后的新容量还是没有传入的所需的最小容量大或等于（主要发生在addAll(Collection&lt;? extends E&gt; c)中） newCapacity = minCapacity;//新容量设为最小容量 elementData = Arrays.copyOf(elementData, newCapacity);//复制新容量 &#125;&#125; 第二种：将单个元素添加到指定位置。12345678910public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1);//确保对象数组elementData有足够的容量，可以将新加入的元素e加进去 System.arraycopy(elementData, index, elementData, index + 1, size - index);//复制数组，将值往后移动 elementData[index] = element; size++;&#125; 12345678910/*** 添加元素时判断elementData是否为空，为空则设置elementData的大小为10*/private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; 由此可见两种添加方式前者比后者节省资源消耗。 VectorVector 也是实现于List接口，底层数据结构和ArrayList类似，也是动态数组存放数据，不过是在 add() 方法的时候使用 synchronized 进行同步写数据，与ArrayList不同的是Vector 线程安全，但是开销较大，所以 Vector 是一个同步容器并不是一个并发容器。 123456789101112131415161718192021222324/*** 在对象数组中尾部添加单个元素和在指定位置添加单个元素* 使用synchronized 进行同步写数据*/public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;public void add(int index, E element) &#123; insertElementAt(element, index);&#125;public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt; \" + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++;&#125;","categories":[],"tags":[]},{"title":"","slug":"ConcurrentHashMap","date":"2018-10-15T16:47:13.076Z","updated":"2018-10-15T16:47:13.076Z","comments":true,"path":"2018/10/16/ConcurrentHashMap/","link":"","permalink":"http://yoursite.com/2018/10/16/ConcurrentHashMap/","excerpt":"","text":"ConcurrentHashMap 源码分析ConcurrentHashMap 简介 正是由于HashMap 不是线程安全的，所以大佬给我们带来了 线程安全的ConcurrentHashMap。 本文的分析的源码是JDK8的版本，与JDK7的版本有很大的差异，java7中 ConcurrentHashMap 由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。 它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用CAS算法。它沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想， 但是为了做到并发，又增加了很多辅助的类，例如TreeBin，Traverser等对象内部类。123456789101112131415161718192021222324252627282930hashmap 的 Node 类static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125;&#125;concurrentHashMap 的 Node 类static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next; Node(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.val = val; this.next = next; &#125;&#125; 其中的concurrentHashMap的 val next 都用了 volatile 修饰，保证了元素可见性。 concurrentHashMap的添加方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); (1). 根据 key 计算出 hashcode 。 int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) (2). 判断是否需要进行初始化。 tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; (3). 根据key的hash值和容器的容量减一后进行与运算定位。如果为空就尝试使用cas插入数据 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED) (4). 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。 tab = helpTransfer(tab, f); else &#123; V oldVal = null; synchronized (f) &#123; (5). 如果都不满足，则利用 synchronized 锁写入数据。 if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; //链表节点 binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; //树节点，与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode. Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); (6). 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。 if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null;&#125; concurrentHashMap 定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。 12345678910111213141516@SuppressWarnings(\"unchecked\")此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125;此函数用于比较tab数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123; return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125;利用volatile方法设置节点位置的值static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123; U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);&#125; concurrentHashMap的获取方法12345678910111213141516171819public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; (1). 根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。 if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) (2). 如果是红黑树那就按照树的方式获取值。 return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123; (3). 都不满足那就按照链表的方式遍历获取值。 if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null; &#125;","categories":[],"tags":[]},{"title":"","slug":"HashMap","date":"2018-10-15T16:47:13.076Z","updated":"2018-10-15T16:47:13.076Z","comments":true,"path":"2018/10/16/HashMap/","link":"","permalink":"http://yoursite.com/2018/10/16/HashMap/","excerpt":"","text":"HashMap 源码分析HashMap 简介HashMap 是一个散列表， 它存储的内容是键值对（key - value）映射。HashMap 继承于 AbstractMap， 实现了Map， Cloneable，Serializable 接口。HashMap 不是线程安全的， 不适用于多线程中， 此外，HashMap中的映射不是有序的。HashMap 里面是一个数组，然后数组中每个元素是一个单项链表。图中Entry 包含四个属性，key，value，hash 值和用于单项链表的next。 重要参数capacity 和 loadFactor。capacity 当前数组容量，始终保持 2^n，默认值为 1&lt;&lt;4，最大为 1&lt;&lt;16, 可以扩容，扩容后数组大小为当前的 2 倍。loadFactor 负载因子，默认为 0.75。threshold 扩容的阈值，等于 capacity * loadFactor。123static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f; HashMap 的 put 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;//第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置 else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //首先，判断该位置的第一个数据和我们要插入的数据，key 是不是\"相等\"，如果是，取出这个节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 如果该节点是代表红黑树的节点，调用红黑树的插值方法 else &#123; // 到这里，说明数组该位置上是一个链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个 // 会触发下面的 treeifyBin，也就是将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // e!=null 说明存在旧值的key与要插入的key\"相等\" // 对于我们分析的put操作，下面这个 if 其实就是进行 \"值覆盖\"，然后返回旧值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125;接下来看 hashmap 的 resize 方法final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候 newCap = oldThr; else &#123; // 对应使用 new HashMap() 初始化后，第一次 put 的时候 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 用新的数组大小初始化新的数组 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; HashMap 的 get方法 1.计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1) 2.判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步 3.判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步 4.遍历链表，直到找到相等(==或equals)的 key public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { 1 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) 2 return first; if ((e = first.next) != null) { if (first instanceof TreeNode) 3 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { 4 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; }","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-10-15T14:59:19.363Z","updated":"2018-10-15T14:59:19.363Z","comments":true,"path":"2018/10/15/hello-world/","link":"","permalink":"http://yoursite.com/2018/10/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}