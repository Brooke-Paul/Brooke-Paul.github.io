{"meta":{"title":"Brooke-Paul","subtitle":"record my daily life","description":"No accumulation of thousands of miles","author":"Brooke-Paul","url":"http://www.uuuup.vip"},"pages":[{"title":"","date":"2018-10-18T18:52:16.773Z","updated":"2018-10-18T18:52:15.122Z","comments":true,"path":"about/index.html","permalink":"http://www.uuuup.vip/about/index.html","excerpt":"","text":"java程序员一枚github: https://github.com/Brooke-Paulblog: http://www.uuuup.vip/email: gentle.taoxue@gmail.com"},{"title":"categories","date":"2018-10-18T18:24:33.864Z","updated":"2018-10-18T18:24:33.858Z","comments":true,"path":"categories/index.html","permalink":"http://www.uuuup.vip/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-18T18:23:14.033Z","updated":"2018-10-18T18:23:12.824Z","comments":true,"path":"tags/index.html","permalink":"http://www.uuuup.vip/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LinkedList的源码分析","slug":"LinkedList","date":"2018-09-15T23:01:34.000Z","updated":"2018-10-18T17:32:17.374Z","comments":true,"path":"2018/09/16/LinkedList/","link":"","permalink":"http://www.uuuup.vip/2018/09/16/LinkedList/","excerpt":"","text":"LinkedList 简介LinkedList 是继承于AbstractSequentialList的双向链表， 它可以被当做堆栈，队列或双端队列使用。LinkedList 实现了List接口， 能对它进行队列操作。LinkedList 实现了Cloneable接口， 覆盖了函数clone(), 支持克隆。LinkedList 实现了Deque接口， 能将 LinkedList当做双端队列使用。LinkedList 实现了Serializable接口，意味着支持序列化， 便于在网络中传输和保存。 12345public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; &#125; LinkedList 是采用链表的方式来实现List接口的,它本身有自己特定的方法， 如: addFirst(),addLast(),getFirst(),getLast(),removeFirst()，removeFirst()，removeLast()。 元素的插入与获取addFirst() 和 addLast()直接插入头部元素 和 尾部元素实现方式1234567891011121314151617181920212223242526272829public void addFirst(E e) &#123; linkFirst(e);&#125;private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //构造头部对象 first = newNode; if (f == null) //如果f为空，则first == last last = newNode; else f.prev = newNode; //否则 头节点为newNode size++; modCount++;&#125;public void addLast(E e) &#123; linkLast(e); &#125;//默认的添加方式也是由此方法实现 void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //构造尾部对象 last = newNode; if (l == null) //如果l为空，则first == last first = newNode; else l.next = newNode; //否则，尾节点为newNode size++; modCount++;&#125; getFirst() 和 getLast()直接获取头部元素 和 尾部元素实现方式123456789101112public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125; public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; LinkedList 查找元素 1234567891011121314151617181920public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; //判断index 是否为 list size 的 一半 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) // 从 0 ~ index 中循环遍历 x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) // 从 index ~ zize - 1 中遍历 x = x.prev; return x; &#125;&#125; 由此得出结论： LinkedList 采用了链表结构，所以在添加和删除方面效率高，查找比较慢 元素的删除removeFirst() 和 removeLast()LinkedList 移除首个元素 和 移除最后一个元素123456789101112131415161718192021222324252627282930313233//removeFirst 主要实现private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; //将当前元素清空 f.next = null; // help GC first = next; //指针后移 if (next == null) last = null; else next.prev = null; //将节点prev置空 size--; modCount++; return element;&#125;//removeLast 主要实现private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; //将当前元素清空 l.prev = null; // help GC last = prev; //指针前移 if (prev == null) first = null; else prev.next = null; //将节点next置空 size--; modCount++; return element;&#125; 主要移除元素底层实现(根据下标移除，根据元素移除)链表结构图如下：将链表重新组装12345678910111213141516171819202122232425E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; //获取当前节点下一节点 final Node&lt;E&gt; prev = x.prev; //获取当前节点上一节点 if (prev == null) &#123; //如果上一节点为空，则首节点下一节点 first = next; &#125; else &#123; //将上一节点的下一节点替换为当前元素的下一节点 prev.next = next; x.prev = null; &#125; if (next == null) &#123; //如果下一节点为空，则尾节点上一节点 last = prev; &#125; else &#123; //将下一节点的上一节点替换为当前元素的下一节点 next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; LinkedList 用作堆栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * LinkedList 实现堆栈的先进后出 */public class StackDemo &#123; private LinkedList linkedList = new LinkedList&lt;&gt;(); /** * 将每次添加的元素都添加到第一个位置 * * @param o */ public void push(Object o) &#123; linkedList.addFirst(o); &#125; /** * 取出第一个元素但是不删除元素 * * @return */ public Object peek() &#123; return linkedList.peek(); &#125; /** * 取出并移除元素 * * @return */ public Object poll() &#123; return linkedList.poll(); &#125; /** * 获取元素个数 * * @return */ public int size() &#123; return linkedList.size(); &#125; /** * 判断堆栈是否为空 * (即判断 linkedList是否为空) * * @return */ public boolean isEmpty() &#123; return linkedList.isEmpty(); &#125; public static void main(String[] args) &#123; StackDemo stackDemo = new StackDemo(); stackDemo.push(\"1\"); stackDemo.push(\"2\"); stackDemo.push(\"3\"); stackDemo.push(\"4\"); stackDemo.push(\"5\"); System.out.println(\"取出第一个元素：：：：\" + stackDemo.peek()); System.out.println(\"取出第一个元素：：：：\" + stackDemo.poll()); while (!stackDemo.isEmpty()) &#123; System.out.print(stackDemo.poll()); &#125; &#125;&#125; LinkedList 用作堆栈 输出结果为1234567891011插入第1个元素,值为 1插入第2个元素,值为 2插入第3个元素,值为 3插入第4个元素,值为 4插入第5个元素,值为 5取出第一个元素 5取出第一个元素 5输出顺序为 4输出顺序为 3输出顺序为 2输出顺序为 1 LinkedList 用作队列123456789101112131415161718192021/** * LinkedList 实现先进先出队列 */public class QueueDemo &#123; public static void main(String[] args) &#123; Queue queue = new LinkedList(); //offer()方法是往队列尾部加入元素 for (int i = 0; i &lt; 5; i++) &#123; queue.offer(i + 1); System.out.println(\"插入第\"+ (i + 1) +\"个元素,\" + \"值为 \" + (i + 1)); &#125; while (!queue.isEmpty()) &#123; System.out.println(\"输出顺序 \" + queue.poll()); &#125; &#125;&#125; 输出结果为12345678910插入第1个元素,值为 1插入第2个元素,值为 2插入第3个元素,值为 3插入第4个元素,值为 4插入第5个元素,值为 5输出顺序 1输出顺序 2输出顺序 3输出顺序 4输出顺序 5","categories":[{"name":"java","slug":"java","permalink":"http://www.uuuup.vip/categories/java/"}],"tags":[{"name":"LinkedList","slug":"LinkedList","permalink":"http://www.uuuup.vip/tags/LinkedList/"}]},{"title":"LinkedHashMap的源码分析","slug":"LinkedHashMap","date":"2018-09-14T23:01:34.000Z","updated":"2018-10-18T17:31:59.134Z","comments":true,"path":"2018/09/15/LinkedHashMap/","link":"","permalink":"http://www.uuuup.vip/2018/09/15/LinkedHashMap/","excerpt":"","text":"LinkedHashMap 简介 LinkedHashMap 继承了 HashMap, 实现了map接口。 所以 LinkedHashMap 包含了 HashMap 的所有功能， 它是一个关联数组，线程不安全，并且key值，value值允许为空。LinkedHashMap 与 HashMap 不同之处是它支持写入顺序排序，访问顺序排序。 顺序展示效果示例代码 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Map map = new LinkedHashMap(); map.put(\"1\", 1); map.put(\"2\", 2); map.put(\"3\", 3); map.put(\"4\", 4); map.put(\"5\", 5); Iterator iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); System.out.println(entry.getKey() + \"::\" + entry.getValue()); &#125; System.out.println(\"accessOrder 设置为 true\"); Map mapOrder = new LinkedHashMap(15, 0.75f, true); mapOrder.put(\"1\", 1); mapOrder.put(\"2\", 2); mapOrder.put(\"3\", 3); mapOrder.put(\"4\", 4); mapOrder.put(\"5\", 5); mapOrder.get(\"1\"); Iterator iterator1 = mapOrder.entrySet().iterator(); while (iterator1.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator1.next(); System.out.println(entry.getKey() + \"::\" + entry.getValue()); &#125;&#125;返回的结果如下： 写入顺序排序1::12::23::34::45::5accessOrder 设置为 true访问顺序排序2::23::34::45::51::1 带着疑问剖析源码，LinkedHashMap的构造函数有五种：123456789101112131415161718192021222324252627282930//默认是false，则迭代时输出的顺序是插入节点的顺序。若为true，则输出的顺序是按照访问节点的顺序。final boolean accessOrder;//指定初始化时的容量，和扩容的加载因子public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false;&#125;//指定初始化时的容量public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125;public LinkedHashMap() &#123; super(); accessOrder = false;&#125;//利用另一个Map 来构建public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; super(); accessOrder = false; putMapEntries(m, false);&#125;//指定初始化时的容量，和扩容的加载因子，以及迭代输出节点的顺序public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 构造函数和HashMap相比，就是增加了一个accessOrder参数。用于控制迭代时的节点顺序。 LinkedHashMap的添加在LinkedHashMap中没有重写HashMap的put方法，但是重写了HashMap中的newNode 方法，在每次构建新节点时，通过linkNodeLast(p)，将新节点链接在内部双向链表的尾部。源码如下：123456789101112131415161718Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; //在构建新节点时，构建的是`LinkedHashMap.Entry` 不再是`Node`. LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125;//每次插入数据是插入到尾节点，并且把方插入的节点的before设置为lastprivate void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; LinkedHashMap的删除LinkedHashMap也没有重写remove()方法，因为它的删除逻辑和HashMap并无区别。重点在于LinkedHashMap 重写了 afterNodeRemoval方法。12345678910111213void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null;//待删除节点 p 的前置后置节点都置空 if (b == null) head = a; else b.after = a; //重新关联b的after节点 if (a == null) tail = b; else a.before = b; //重新关联a的before节点 &#125; LinkedHashMap的查找LinkedHashMap 重写了 get() 和 getOrDefault() 方法。对比HashMap的实现可以发现只是增加了在成员变量(构造函数时赋值)accessOrder = true 的情况下会调用 afterNodeAccess() 方法。1234567891011121314151617181920212223242526272829303132333435363738394041public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125;public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return defaultValue; if (accessOrder) afterNodeAccess(e); return e.value;&#125;//此方法的目的是将不是尾部的元素并且accessOrder = true的节点e移动至内部的双向链表的尾部void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; //将p的设置为尾节点 if (b == null) // 如果p的前置节点为null，则p以前是头节点，所以更新现在的头节点为p的后置节点a head = a; else //否则更新b的后置节点为a b.after = a; if (a != null) // 如果p的后置节点不为null， 则更新a的前置节点为b a.before = b; else // 如果p的后置节点为null，则p就是尾节点，更新last 引用为b last = b; if (last == null) //如果尾节点为空，则链表中只有一个节点 head = p; else &#123; // 否则更新更新p的前置节点为原尾节点last，last的后置节点为p p.before = last; last.after = p; &#125; tail = p;//尾节点的引用赋值成p ++modCount; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://www.uuuup.vip/categories/java/"}],"tags":[{"name":"LinkedHashMap","slug":"LinkedHashMap","permalink":"http://www.uuuup.vip/tags/LinkedHashMap/"}]},{"title":"HashSet的源码分析","slug":"HashSet","date":"2018-09-13T23:01:34.000Z","updated":"2018-10-18T18:18:48.930Z","comments":true,"path":"2018/09/14/HashSet/","link":"","permalink":"http://www.uuuup.vip/2018/09/14/HashSet/","excerpt":"","text":"HashSet 简介HashSet 是一个没有重复元素的集合。它是由 HashMap 实现的， 无序且允许空值。HashSet 是非线程同步的，没有提供数据访问保护，在多线程环境中容易导致多个线程更改数据后造成数据脏读。 HashSet 的添加方法12345678//map是一个HashMap&lt;E, Object&gt;对象，HashSet是由一个HashMap实例支持的private transient HashMap&lt;E,Object&gt; map;//PRESENT是一个static final Object对象，用来作为HashMap中的value值。private static final Object PRESENT = new Object();//熟悉hashmap的实现方式的话很容易理解put方法，对象作为key值，不允许重复，value使用 PRESENT。 public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; HashSet 的查找方法1234//如果此set包含指定元素，则返回 truepublic boolean contains(Object o) &#123; return map.containsKey(o);&#125; HashSet 的清空与移除方法 123456789//如果指定元素存在于此set中，则将其移除public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125;//从此set中移除所有元素public void clear() &#123; map.clear();&#125; HashSet 的遍历方式12345678910Set set = new HashSet();set.add(\"!\");set.add(\"a\");set.add(\"1\");Iterator iterator = set.iterator();//通过keyset的方式获取key值集合的迭代器while (iterator.hasNext()) &#123; String key = (String) iterator.next(); System.out.println(key);&#125;","categories":[{"name":"java","slug":"java","permalink":"http://www.uuuup.vip/categories/java/"},{"name":"collection","slug":"java/collection","permalink":"http://www.uuuup.vip/categories/java/collection/"}],"tags":[{"name":"HashSet","slug":"HashSet","permalink":"http://www.uuuup.vip/tags/HashSet/"}]},{"title":"HashMap的源码分析","slug":"HashMap","date":"2018-09-12T23:01:34.000Z","updated":"2018-10-18T18:10:46.558Z","comments":true,"path":"2018/09/13/HashMap/","link":"","permalink":"http://www.uuuup.vip/2018/09/13/HashMap/","excerpt":"","text":"HashMap 简介HashMap 是一个散列表， 它存储的内容是键值对（key - value）映射。HashMap 继承于 AbstractMap， 实现了Map， Cloneable，Serializable 接口。HashMap 不是线程安全的， 不适用于多线程中， 此外，HashMap中的映射不是有序的。HashMap 里面是一个数组，然后数组中每个元素是一个单项链表。图中Entry 包含四个属性，key，value，hash 值和用于单项链表的next。 重要参数capacity 和 loadFactor。capacity 当前数组容量，始终保持 2^n，默认值为 1&lt;&lt;4，最大为 1&lt;&lt;16, 可以扩容，扩容后数组大小为当前的 2 倍。loadFactor 负载因子，默认为 0.75。threshold 扩容的阈值，等于 capacity * loadFactor。123static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f; HashMap 的 put 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;//第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置 else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //首先，判断该位置的第一个数据和我们要插入的数据，key 是不是\"相等\"，如果是，取出这个节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 如果该节点是代表红黑树的节点，调用红黑树的插值方法 else &#123; // 到这里，说明数组该位置上是一个链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个 // 会触发下面的 treeifyBin，也就是将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // e!=null 说明存在旧值的key与要插入的key\"相等\" // 对于我们分析的put操作，下面这个 if 其实就是进行 \"值覆盖\"，然后返回旧值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125;接下来看 hashmap 的 resize 方法final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候 newCap = oldThr; else &#123; // 对应使用 new HashMap() 初始化后，第一次 put 的时候 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 用新的数组大小初始化新的数组 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; HashMap 的 get方法1.计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)2.判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步3.判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步4.遍历链表，直到找到相等(==或equals)的 key 1234567891011121314151617181920212223public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; 1 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) 2 return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) 3 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; 4 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://www.uuuup.vip/categories/java/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://www.uuuup.vip/tags/HashMap/"}]},{"title":"ConcurrentHashMap的源码分析","slug":"ConcurrentHashMap","date":"2018-09-11T23:01:34.000Z","updated":"2018-10-18T17:52:56.017Z","comments":true,"path":"2018/09/12/ConcurrentHashMap/","link":"","permalink":"http://www.uuuup.vip/2018/09/12/ConcurrentHashMap/","excerpt":"","text":"ConcurrentHashMap 简介 正是由于HashMap 不是线程安全的，所以大佬给我们带来了 线程安全的ConcurrentHashMap。 本文的分析的源码是JDK8的版本，与JDK7的版本有很大的差异，java7中 ConcurrentHashMap 由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。 它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用CAS算法。它沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想， 但是为了做到并发，又增加了很多辅助的类，例如TreeBin，Traverser等对象内部类。123456789101112131415161718192021222324252627282930hashmap 的 Node 类static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125;&#125;concurrentHashMap 的 Node 类static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next; Node(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.val = val; this.next = next; &#125;&#125; 其中的concurrentHashMap的 val next 都用了 volatile 修饰，保证了元素可见性。 concurrentHashMap的添加方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); (1). 根据 key 计算出 hashcode 。 int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) (2). 判断是否需要进行初始化。 tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; (3). 根据key的hash值和容器的容量减一后进行与运算定位。如果为空就尝试使用cas插入数据 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED) (4). 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。 tab = helpTransfer(tab, f); else &#123; V oldVal = null; synchronized (f) &#123; (5). 如果都不满足，则利用 synchronized 锁写入数据。 if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; //链表节点 binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; //树节点，与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode. Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); (6). 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。 if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null;&#125; concurrentHashMap 定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。 12345678910111213141516@SuppressWarnings(\"unchecked\")此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125;此函数用于比较tab数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123; return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125;利用volatile方法设置节点位置的值static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123; U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);&#125; concurrentHashMap的获取方法12345678910111213141516171819public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; (1). 根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。 if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) (2). 如果是红黑树那就按照树的方式获取值。 return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123; (3). 都不满足那就按照链表的方式遍历获取值。 if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://www.uuuup.vip/categories/java/"}],"tags":[{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","permalink":"http://www.uuuup.vip/tags/ConcurrentHashMap/"}]},{"title":"ArrayList/Vector的源码分析","slug":"ArrayList","date":"2018-09-11T09:01:34.000Z","updated":"2018-10-18T17:52:26.842Z","comments":true,"path":"2018/09/11/ArrayList/","link":"","permalink":"http://www.uuuup.vip/2018/09/11/ArrayList/","excerpt":"","text":"ArrayListArrayList 是动态数组，其实就是Array的复杂版本，它提供了动态增加和减少元素的功能，实现了List，RandomAccess, Collection接口，ArrayList不是线程安全的，建议在单线程中使用ArrayList。 ArrayList 包含两个重要属性分别是： 12345678910/*** elementData；* transient 关键字修饰表示防止此字段被序列化* 避免了浪费资源去存储没有的数据* size:* elementData中已存放的元素的个数，注意：不是elementData的容量* */transient Object[] elementData;private int size; 因为 elementData无法被序列化， 所以ArrayList 的序列化和反序列化依赖writeObject 和 readObject方法来实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; /** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 往ArrayList 中添加元素单个元素有两种方式第一种：将单个元素添加到尾部，并将size + 1。123456789101112131415161718192021222324/** * 向elementData中添加元素 */public boolean add(E var1) &#123; this.ensureCapacityInternal(this.size + 1);//确保对象数组elementData有足够的容量，可以将新加入的元素e加进去 this.elementData[this.size++] = var1;//加入新元素e，size加1 return true;&#125;/** * 确保数组的容量足够存放新加入的元素，若不够，要扩容 */public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length;//获取数组大小（即数组的容量） //当数组满了，又有新元素加入的时候，执行扩容逻辑 if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3) / 2 + 1;//新容量为旧容量的1.5倍+1 if (newCapacity &lt; minCapacity)//如果扩容后的新容量还是没有传入的所需的最小容量大或等于（主要发生在addAll(Collection&lt;? extends E&gt; c)中） newCapacity = minCapacity;//新容量设为最小容量 elementData = Arrays.copyOf(elementData, newCapacity);//复制新容量 &#125;&#125; 第二种：将单个元素添加到指定位置。12345678910public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1);//确保对象数组elementData有足够的容量，可以将新加入的元素e加进去 System.arraycopy(elementData, index, elementData, index + 1, size - index);//复制数组，将值往后移动 elementData[index] = element; size++;&#125; 12345678910/*** 添加元素时判断elementData是否为空，为空则设置elementData的大小为10*/private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; 由此可见两种添加方式前者比后者节省资源消耗。 VectorVector 也是实现于List接口，底层数据结构和ArrayList类似，也是动态数组存放数据，不过是在 add() 方法的时候使用 synchronized 进行同步写数据，与ArrayList不同的是Vector 线程安全，但是开销较大，所以 Vector 是一个同步容器并不是一个并发容器。 123456789101112131415161718192021222324/*** 在对象数组中尾部添加单个元素和在指定位置添加单个元素* 使用synchronized 进行同步写数据*/public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;public void add(int index, E element) &#123; insertElementAt(element, index);&#125;public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt; \" + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://www.uuuup.vip/categories/java/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"http://www.uuuup.vip/tags/ArrayList/"},{"name":"Vector","slug":"Vector","permalink":"http://www.uuuup.vip/tags/Vector/"}]}]}