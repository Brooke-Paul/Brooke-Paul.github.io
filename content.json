{"meta":{"title":"Brooke-Paul","subtitle":"record my daily life","description":"No accumulation of thousands of miles","author":"Brooke-Paul","url":"http://www.uuuup.vip"},"pages":[{"title":"","date":"2018-10-19T07:37:49.825Z","updated":"2018-10-19T07:31:22.491Z","comments":true,"path":"README.html","permalink":"http://www.uuuup.vip/README.html","excerpt":"","text":"LinkedList的源码分析LinkedHashMap的源码分析HashSet的源码分析HashMap的源码分析ConcurrentHashMap的源码分析ArrayList/Vector的源码分析"},{"title":"","date":"2018-10-18T18:52:16.773Z","updated":"2018-10-18T18:52:15.122Z","comments":true,"path":"about/index.html","permalink":"http://www.uuuup.vip/about/index.html","excerpt":"","text":"java程序员一枚github: https://github.com/Brooke-Paulblog: http://www.uuuup.vip/email: gentle.taoxue@gmail.com"},{"title":"categories","date":"2018-10-18T18:24:33.864Z","updated":"2018-10-18T18:24:33.858Z","comments":true,"path":"categories/index.html","permalink":"http://www.uuuup.vip/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-22T14:35:12.633Z","updated":"2018-10-18T18:23:12.824Z","comments":true,"path":"tags/index.html","permalink":"http://www.uuuup.vip/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java线程安全","slug":"jvm/Java线程安全","date":"2019-01-26T16:00:00.000Z","updated":"2019-01-27T09:22:48.986Z","comments":true,"path":"2019/01/27/jvm/Java线程安全/","link":"","permalink":"http://www.uuuup.vip/2019/01/27/jvm/Java线程安全/","excerpt":"","text":"Java操作共享数据Java操作共享数据分为五类。不可变，绝对线程安全，相对线程安全，线程兼容和线程对立。 不可变不可变的对象一定是线程安全的，只要一个不可变对象被正确的构造出来（没有发生this引用逃逸的情况)，那么外部访问的可见状态永远不会改变。 12345678910111213141516171819202122232425 /** * 第一种：被final修饰的基本类型值不能改变 */ private final int number = 5; private final String message = \"hello\"; /** * 第二种：被final修饰的对象, 对象不能改变，但是对象中的变量值可以改变 */ private final Person person = new Person(\"zhangshan\"); public static void main(String[] args) &#123; ThreadSafetyDemo threadSafetyDemo = new ThreadSafetyDemo(); System.out.println(\"不可变对象int：\" + threadSafetyDemo.number); System.out.println(\"不可变对象string：\" + threadSafetyDemo.message); System.out.println(\"不可变对象person：\" + threadSafetyDemo.person); threadSafetyDemo.person.setName(\"lishi\"); //Cannot assign a value to final variable 'person'// threadSafetyDemo.person = new Person(); System.out.println(\"不可变对象person：\" + threadSafetyDemo.person); &#125; 这里分析一下this引用逃逸，当线程RunablTest1还未初始化demo对象时，线程RunablTest2尝试获取未初始化demo对象的变量，代码如下：123456789101112131415161718192021222324252627282930313233343536373839private int i = 0;static ThreadSafetyDemo demo;public ThreadSafetyDemo() &#123; i = 1; System.out.println(\"hello\");&#125;private static class RunablTest1 implements Runnable &#123; @Override public void run() &#123; demo = new ThreadSafetyDemo(); &#125;&#125;private static class RunablTest2 implements Runnable &#123; @Override public void run() &#123; try &#123; System.out.println(demo.i); &#125; catch (NullPointerException e) &#123; System.out.println(\"发生空指针错误：普通变量j未被初始化\"); &#125; try &#123; System.out.println(demo.i); &#125; catch (NullPointerException e) &#123; System.out.println(\"发生空指针错误：final变量i未被初始化\"); &#125; &#125;&#125;public static void main(String[] args) &#123; new Thread(new RunablTest2()).start(); new Thread(new RunablTest1()).start();&#125;输出结果：发生空指针错误：普通变量j未被初始化发生空指针错误：final变量i未被初始化hello 绝对线程安全绝对线程安全类定义是非常严格的，要实现一个绝对线程安全的类通常需要付出很大的、甚至有时候是不切实际的代价。 相对线程安全相对的线程安全就是所讲的线程安全，在大部分线程安全类都属于这种类型，例如Vector，HashTable等。 线程兼容线程兼容是指对象本身不是线程安全的，但可以通过同步手段保证对象在并发的同时安全的使用。 线程对立线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境下同时持有一个线程对象。","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://www.uuuup.vip/categories/Java虚拟机/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.uuuup.vip/tags/JVM/"}]},{"title":"虚拟机性能监控工具","slug":"jvm/虚拟机性能监控工具","date":"2019-01-19T16:00:00.000Z","updated":"2019-01-24T14:01:24.244Z","comments":true,"path":"2019/01/20/jvm/虚拟机性能监控工具/","link":"","permalink":"http://www.uuuup.vip/2019/01/20/jvm/虚拟机性能监控工具/","excerpt":"","text":"JDK命令行工具虚拟机进程状况工具jps1). jps -l 输出主类的全名 2). jps -v 输出虚拟机进程启动时的JVM参数 虚拟机统计信息监控工具jstat1). jstat -gc 监视Java堆的状况，包括Eden区，survivor区，老年代，永久代的容量，已用空间以及GC时间合计的信息。 2). jstat -gcutil 监视内容基本与-gc相同，单输出内容主要是使用空间占比。 java堆栈跟踪工具jstack1). jstack -l 除堆栈外，展示关于锁的附加信息。","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://www.uuuup.vip/categories/Java虚拟机/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.uuuup.vip/tags/JVM/"}]},{"title":"JVM类加载机制","slug":"jvm/JVM类加载机制","date":"2019-01-18T16:00:00.000Z","updated":"2019-01-22T15:16:26.523Z","comments":true,"path":"2019/01/19/jvm/JVM类加载机制/","link":"","permalink":"http://www.uuuup.vip/2019/01/19/jvm/JVM类加载机制/","excerpt":"","text":"类加载机制虚拟机把描述的.class文件加载到内存，并对数据进行校验、准备、解析和初始化，最终能够被形成被JVM可以直接使用的Java类型的过程，这就是虚拟机的类加载机制。 类加载的生命周期类从被加载到虚拟机内存开始，到卸载出内存结束包含七个阶段。包括加载，验证，准备，解析，初始化，使用，卸载。其中验证准备以及解析三个部分被称为连接。 类加载的过程1). 加载阶段在加载阶段，虚拟机会通过类的全限定名来获取定义此类的二进制流。将字节流所代表的静态存储结构转换为方法区的运行时数据结构。在内存中生成一个代表这个类的.class对象，作为这个类的各种数据的访问人口。 2). 验证阶段验证是连接阶段的第一步，目的是确保.class文件的字节流信息符合虚拟机的要求。验证阶段主要检验四个点： 文件格式校验(校验文件编码，校验文件常量引用等) 元数据验证(对字节码描述信息进行语义分析，例如类是否有父类(Object)，类继承时是否包含final修饰，以及类是否实现了接口的所有方法等等) 字节码验证(主要确定语义合法，变量类型转换有效等等) 符号引用验证(例如类中方法以及字段的引用是否有效，以及是否能够被访问到等等) 3). 准备阶段准备阶段正式为类变量分配内存并且设置类变量的初始值，这些变量使用方法区的内存进行分配。值的一提的是准备阶段内存分配的仅包括被static修饰的变量，而不包括实例变量。默认情况下初始值为零值，但是如果被final修饰的变量在这个阶段会将其置为定义的值。 4). 解析阶段虚拟机将常量池内的符号引用替换为直接引用的过程叫做解析。 类或接口的解析 字段的解析 类方法解析 接口方法解析 5). 初始化阶段类加载过程的最后一步称为类初始化阶段。初始化阶段是执行类构造器&lt;cinit&gt;()方法的过程，并且静态语句块只能访问到定义到静态语句块之前的变量。 类加载器类加载器用于加载类，并且对于任意一个类，被类加载器加载后都可以在虚拟机中确定唯一性。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。通俗一点来讲，要判断两个类是否“相同”，前提是这两个类必须被同一个类加载器加载，否则这个两个类不“相同”。这里指的“相同”，包括类的.class对象的equals()方法、isAssignableFrom()方法、isInstance()方法、instanceof关键字等判断出来的结果。 双亲委派模型对Java 虚拟机来说，只存在两种类加载器：一种是启动类加载器Bootstrap ClassLoader，另一种是所有其他的类加载器。其中启动类加载器Bootstrap ClassLoader加载&lt;JAVA_HOME&gt;\\lib目录下核心库。其他类加载器可以分为扩展类加载器Extension ClassLoader，和 应用程序类加载器Application ClassLoader。扩展类加载器Extension ClassLoader 主要加载&lt;JAVA_HOME&gt;\\lib\\ext目录下扩展包。应用程序类加载器Application ClassLoader 主要加载用户路径classpath下的指定类库。 如下图所示： 该图即为类加载的双亲委派模型。除了顶层的类加载器之外，其余的所有类加载器必须有自己的父类加载器。工作过程为：如果某个类需要被加载时默认不会自己尝试加载类，而是委托自己的父类加载器去完成。只有父类加载器无法完成该类的加载时抛出抛出异常，然后该类加载器才会尝试自己加载请求。类加载器伪代码如下： 123456789判断该类是否被加载过if（没有被加载)&#123; try&#123; 请求父级加载器类加载 &#125; catch() &#123; 如果父级无法完成类加载，异常处理 &#125; 尝试自己去进行类加载&#125;","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://www.uuuup.vip/categories/Java虚拟机/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.uuuup.vip/tags/JVM/"}]},{"title":"垃圾收集与内存分配","slug":"jvm/垃圾收集与内存分配","date":"2019-01-15T16:00:00.000Z","updated":"2019-01-17T17:15:21.819Z","comments":true,"path":"2019/01/16/jvm/垃圾收集与内存分配/","link":"","permalink":"http://www.uuuup.vip/2019/01/16/jvm/垃圾收集与内存分配/","excerpt":"","text":"垃圾收集垃圾收集（Garbage Collection), 俗称 GC。在系统中哪些内存需要回收？什么时候回收？怎样回收呢？当垃圾收集成为系统达到性能最优的阻碍时，我们就需要针对垃圾收集进行必要的监控与处理。 对象是否存活？Java堆中存放几乎所有对象实例，垃圾收集器在回收对象时需要判断对象是否存活。哪些方法能够判断对象可以被回收呢？1). 引用计数算法给对象添加一个引用计数器，每当引用一次计数器 + 1， 引用失效 - 1。优点：实现简单，判定效率高。缺点：无法判断对象之间相互引用的问题。2). 可达性分析算法基本思路是通过GC Roots的对象作为起始点，向下开始搜索，所走过的路径成为引用链（Reference Chain）,当一个对象到 GC Roots 没有任何引用链相连时，表示该对象不可用，即是可以被回收的对象。在 Java 语言中，可作为GC Roots的对象包括下面几种：(1).虚拟机栈（栈帧中的本地变量表)中引用的对象。(2).方法区中类静态属性引用的对象。(3).方法区中常量引用的对象。(4).本地方法栈中JNI引用的对象。 对象引用Java中对对象的引用分为强引用，软引用，弱引用，虚引用四种，四种引用的强度依次递减。1).强引用指的是类似Object object = new Object() 这类引用，只要强引用存在，引用的对象永远不会被垃圾收集器回收。2).软引用描述的是有用但非必需的对象，对于软引用关联的对象，在系统将要发生内存溢出之前，系统将会把这些对象进行二次回收，如果这次回收还没有足够的内存，才会发生内存溢出异常。3).弱引用也是描述非必需的对象，但是它的强度比软引用更弱一些， 被弱引用关联的对象只能生存到一下次垃圾收集之前。当垃圾回收的时候，无论内存足够，被弱引用关联的对象都会被回收。4).虚引用是最弱的一种引用关系，若有若无。 垃圾收集算法1).标记-清除算法先扫描并标记需要回收的对象，然后清除。标记和清除的效率都不是很高。2).复制算法把内存分为两块，当使用的一块内存不足时，将所有存活的对象复制到另一块，回收当前一整块内存被分为eden区survivor 区，eden:survivor = 8:13).标记整理算法标记出需要清理的对象，然后其余对象移动到另一端4).分代收集算法 （最优法）新生代使用复制算法 （新生代对象存活时间短，采用复制算法）永久代使用其他两种算法 （永久代对象存活时间较长） 垃圾收集器Serial 是单线程收集器，并且工作时必须暂停其他线程工作。ParNew 是 Serial 收集器的多线程版本，支持多条垃圾收集器并行工作。Parallel Scavenge 是一个新生代收集器，使用复制算法的收集器，也是并行的多线程收集器。Serial Old 是 Serial 收集器的老年代版本，也是一个单线程收集器，使用的是 标记-整理算法。Parallel Old 是 Parallel Scavenge 的老年代版本，使用多线程 和 标记-整理算法。CMS 是 以一种以获取最短回收停顿时间为目标的收集器，采用的是标记-清除算法。 停顿时间短，用户体验好，目前来看 CMS 收集器非常符合这类应用的需求。G1收集器的优势：并行与并发， 分代收集， 空间整理 （标记整理算法，复制算法）。 GC对象在新生代Eden区中分配，当区域内存不足时，将会发生Minor GC（称为新生代GC)。对发生在老年代的GC称为Major GC， Major GC会比Minor GC的速度慢10倍以上。为了计算哪些对象在新生代，那些对象在老年代，虚拟机给每个对象定义了年龄计数器， 对象在Eden区发生了 Minor GC后任然存活并且能够被 Survivor容纳的话，将会移到Survivor区域，并且设置年龄为1，对象每熬过一次Minor GC，年龄 +1。当对象年龄达到晋升老年代阈值时，晋升到老年代。（默认年龄为15岁， 可以通过参数 -XX： MaxTenuringThreshold)设置。","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://www.uuuup.vip/categories/Java虚拟机/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.uuuup.vip/tags/JVM/"}]},{"title":"Java内存区域","slug":"jvm/Java内存区域","date":"2019-01-14T16:00:00.000Z","updated":"2019-01-20T10:02:33.715Z","comments":true,"path":"2019/01/15/jvm/Java内存区域/","link":"","permalink":"http://www.uuuup.vip/2019/01/15/jvm/Java内存区域/","excerpt":"","text":"Java 运行时数据区域Java虚拟机所管理的内存包括如下图所示的几个运行时数据区域 Java方法区方法区是线程共享区域，用于存储已被虚拟机加载的类信息，常量，静态变量，以及编译器编译后的代码等数据。 运行时常量池属于方法取得一部分。 Java栈Java 栈分为两块，包含虚拟机栈和本地方法栈。 1）虚拟机栈虚拟机栈是线程私有的，它的生命周期与线程相同，每个方法运行时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出入口信息等，每个方法从调用直至执行完成的过程，就对应着一个栈帧从虚拟机中入栈到出栈的过程。其中局部变量表存放了8种基本类型数据，还有对象的引用。在Java虚拟机中对栈规定了两种异常情况，如果请求的栈的深度大于虚拟机所允许栈的深度，将抛出StackOverflowError异常，如果虚拟机可以动态扩展并且在扩展时无法申请足够的内存，那么将会抛出OutOfMemoryError异常。 2）本地方法栈本地方法栈与虚拟机栈所发挥的作用类似，区别在于虚拟机栈为虚拟机执行Java方法服务， 本地方法栈为虚拟机执行Native方法服务。与虚拟机栈一样，本地方法栈也会抛出上面两种异常。 Java堆Java堆是线程共享的。对大多数应用来说， Java堆是 虚拟机中被管理的最大的一块线程共享区域，在该区域存放的是对象的实例，几乎所有的对象实例都在堆中分配。Java堆是垃圾收集器管理的主要区域。现在的收集器基本都采用分代收集法，堆中可以细分为新生代和老年代，再细致一点可以分为 Eden区，From Survivor区域，To Survivor区域。 程序计数器程序计数器是一块较小的内存空间，可以作为线程的指示器。字节码解释器工作是通过改变记数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都依赖计数器来完成。","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://www.uuuup.vip/categories/Java虚拟机/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.uuuup.vip/tags/JVM/"}]},{"title":"CAS深入解析","slug":"concurrent/CAS深入解析","date":"2019-01-12T16:00:00.000Z","updated":"2019-01-27T16:58:00.571Z","comments":true,"path":"2019/01/13/concurrent/CAS深入解析/","link":"","permalink":"http://www.uuuup.vip/2019/01/13/concurrent/CAS深入解析/","excerpt":"","text":"CASCAS（Compare and swap）就是比较和替换， 是一种通过硬件实现并发安全的技术。CAS 是 JAVA 并发包的实现基础，包含了三个操作数，需要读写的内存位置V，进行比较的值A，以及写入的新值。当且仅当V的值等于A时，CAS 才会通过原子方式用新值替换旧值。模拟CAS 原理123456789101112131415public class CASDemo &#123; private int value; public synchronized int get() &#123; return value; &#125; 旧值与传入相同，更改新值 public synchronized int compareAndSwap(int oldValue, int newValue) &#123; if (this.value == oldValue) &#123; this.value = newValue; &#125; return oldValue; &#125;&#125; 乐观锁乐观锁的核心算法就是采用的CAS, CAS具有原子性。乐观锁避免了悲观锁独占的现象，并且提高了并发性能。但是，乐观锁也有自己的不足：1). 乐观锁只能保证一个共享变量的原子操作。2). 长时间自旋操作可能导致线程开销太大。3). CAS的核心是通过比较内存值与预期值是否一样判断内存值是否被改动过，但是这个逻辑有些不严谨。比如原来内存值为A，后来被某个线程改为B，最后又被改成了A，则CAS认为内存值未被改变过，这种场景对依赖过程值的情景运算结果影响很大，那有什么解决办法呢？解决的思路就是给每个替换时加上版本号。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"CAS","slug":"CAS","permalink":"http://www.uuuup.vip/tags/CAS/"}]},{"title":"ThreadLocal的源码分析","slug":"concurrent/ThreadLocal的源码分析","date":"2019-01-09T16:00:00.000Z","updated":"2019-01-27T16:58:00.580Z","comments":true,"path":"2019/01/10/concurrent/ThreadLocal的源码分析/","link":"","permalink":"http://www.uuuup.vip/2019/01/10/concurrent/ThreadLocal的源码分析/","excerpt":"","text":"ThreadLocal的介绍ThreadLocal用于保存某个线程中共享变量。在同一个线程中，共享变量之间的访问时隔离的，无法跨线程访问。因此ThreadLocal可以用作人员信息的保存，以及展示。 ThreadLocal提供的主要方法ThreadLocal.set() 用于当前线程信息保存12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 在Thread 中 threadLocals 作为变量，用于存储 ThreadLocalMap。 set 方法获取当前线程后首先调用 getMap。 1234567/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 如果当前线程的 getMap 获取的 t.threadLocals 为空，则调用 createMap 方法，createMap 的实现方式如下： 1234567891011void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125;构造 一个 ThreadLocalMap 对象 并将 key， value 保存到Entry数组中。ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125; 如果当前线程的 getMap 获取的 t.threadLocals 不为空，则将value保存到 ThreadLocalMap。 12345678910111213static class ThreadLocalMap &#123; Entry 继承自 WeakReference， 当对象不再使用时会被回收，避免内存泄漏。 static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125;&#125; ThreadLocal.get() 用于当前线程信息获取12345678910111213 public T get() &#123; Thread t = Thread.currentThread(); 获取当前线程， ThreadLocalMap map = getMap(t); 获取当前线程本地变量 if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 如果 本地线程变量不为空，从getEntry 中获取 Entry 对象 12345678 private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125; 否则调用 setInitialValue 方法。 1234567891011给一个空的value值， 之后的逻辑与 `ThreadLocal` 的 `set` 方法一致，获取当前线程本地变量，如果不为空重新设值，为空创建新的 `ThreadLocalMap`对象。 private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; &#125; ThreadLocal.remove() 用于当前线程移除本地变量12345public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); &#125;","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"http://www.uuuup.vip/tags/ThreadLocal/"}]},{"title":"Synchronized与ReadWriteLock的区别","slug":"concurrent/Synchronized与ReadWriteLock的区别","date":"2019-01-06T16:00:00.000Z","updated":"2019-01-27T09:22:48.982Z","comments":true,"path":"2019/01/07/concurrent/Synchronized与ReadWriteLock的区别/","link":"","permalink":"http://www.uuuup.vip/2019/01/07/concurrent/Synchronized与ReadWriteLock的区别/","excerpt":"","text":"SynchronizedSynchronized关键字是最基本的互斥同步，经过编译之后，会在同步块的前后形成monitorenter和monitorexit两个字节码指令，在和执行monitorenter指令时，首先会尝试获取对象的锁，把锁的计数器加一。相应的，在执行monitorexit指令时会将计数器的值减一，当计数器的值为零时锁会被释放。如果获取对象锁失败，那么当前线程就会阻塞等待，直到对象锁被另一个线程释放为止。 Synchronized与ReadWriteLock相同点1.在多线程并发编程中都能实现同步，当某个方法被Synchronized修饰时，其它的线程无法访问当前方法，只有阻塞等待此方法同步完成后获取锁。2.ReadWriteLock为读写锁，适用情况为读多写少的场景，和Synchronized一样可以锁住某个方法，但是得手动释放锁。3.Synchronized 和 ReadWriteLock 都是可重入锁，即一个线程在获取某个锁后，还可以继续获取同一个锁。 Synchronized与ReadWriteLock区别在内置锁Synchronized中使用简洁，不需要每次使用后手动释放锁，而ReadWriteLock必须每次使用后手动释放锁。在内置锁Synchronized中不能手动中断锁操作，而ReadWriteLock可以手动取消锁。ReadWriteLock是一种性能优化措施，执行读锁时效率比Synchronized 更高。 总结：显示锁的设置上要灵活些，比如定时，轮询，以及中断操作等，但是使用难度要大些，并且容易忽略锁的释放。当Synchronized无法满足多线程同步时才使用ReadWriteLock，否则尽量使用Synchronized。ReadWriteLock使用场景，当允许多个读线程并发的访问被保护的对象时可以使用读写锁，提高程序可伸缩性。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"Lock","slug":"Lock","permalink":"http://www.uuuup.vip/tags/Lock/"}]},{"title":"锁的使用","slug":"concurrent/显示锁的使用","date":"2019-01-05T16:00:00.000Z","updated":"2019-01-27T16:58:00.566Z","comments":true,"path":"2019/01/06/concurrent/显示锁的使用/","link":"","permalink":"http://www.uuuup.vip/2019/01/06/concurrent/显示锁的使用/","excerpt":"","text":"显示锁介绍java5.0之前，线程对共享对象的访问可以使用synchronized 和 volatile。java5.0之后新增了一种新机制， ReentrantLock。它并不是一种替代内置锁的方法，而是作为一种当内置锁机制不适用时的高级功能使用。Lock 定义了一种加锁操作， 与内置锁不同的是提供了一种可轮询的，可定时的，以及可中断的获取锁的操作。加锁和释放锁的操作都是显示执行的。123456789101112void lock(); //加锁操作void lockInterruptibly() throws InterruptedException; //该锁与lock相似，但可以被中断boolean tryLock(); //尝试获取锁操作boolean tryLock(long time, TimeUnit unit) throws InterruptedException; //在指定的时间内尝试获取所操作void unlock(); //释放锁操作Condition newCondition(); //创建Condition对象，精细的控制多线程的休眠与唤醒 显示锁的三种使用方式第一种 轮询锁1234567891011121314151617181920212223242526轮询顺序尝试获取两个锁，如果顺利获取并且转账金额小于当前用户的实际金额，加锁转账，释放锁。while (true) &#123; if (fromAcct.lock.tryLock()) &#123; try &#123; if (toAcct.lock.tryLock()) &#123; try &#123; if (fromAcct.getBalance().compareTo(amount) &lt; 0) throw new InsufficientFundsException(); else &#123; fromAcct.debit(amount); toAcct.credit(amount); return true; &#125; &#125; finally &#123; toAcct.lock.unlock(); &#125; &#125; &#125; finally &#123; fromAcct.lock.unlock(); &#125; &#125; if (System.nanoTime() &lt; stopTime) return false; NANOSECONDS.sleep(fixedDelay + rnd.nextLong() % randMod); &#125; &#125; 第二种 定时锁1234567891011121314尝试获取锁，设置当前锁的失效时间，如果在指定时间内未获取到锁，返回失败信息，获取锁后更改信息，最后释放锁public boolean timeLockTest(String message, long timeout, TimeUnit unit) throws InterruptedException &#123; long nanosToLock = unit.toNanos(timeout) - estimatedNanosToSend(message); if (!lock.tryLock(nanosToLock, NANOSECONDS)) return false; try &#123; return doSomeThing(message); &#125; finally &#123; lock.unlock(); &#125; &#125; 第三种 可中断锁123456789设置获取锁的同时保持对中断的响应，然后取消获取锁操作public boolean sendSharedLine() &#123; lock.lockInterruptibly(); try &#123; return cancelSendSharedLine(); &#125; finally &#123; lock.unlock(); &#125;&#125; 锁的公平性创建锁对象时默认创建非公平锁，非公平锁允许插队，公平锁必须按照顺序来获取锁。在获取锁的激烈竞争下，非公平锁的性能高于公平锁。 总结在Synchronized 中和 ReentrantLock中做出选择 ReentrantLock 的性能优于内置锁， 可以作为一种高级工具使用，功能包括可定时的，可轮询的，可中断的所获取操作。但是对于内置锁来说，它任然具有很大的优势，不需要自己手动去释放锁，并且使用简介紧凑。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"Lock","slug":"Lock","permalink":"http://www.uuuup.vip/tags/Lock/"}]},{"title":"Java线程的优化","slug":"concurrent/线程的优化","date":"2019-01-01T16:00:00.000Z","updated":"2019-01-02T16:57:34.857Z","comments":true,"path":"2019/01/02/concurrent/线程的优化/","link":"","permalink":"http://www.uuuup.vip/2019/01/02/concurrent/线程的优化/","excerpt":"","text":"为什么使用线程?因为串行执行任务时，所有的任务节点必须按照顺序执行，如果处理任务时执行时间过长，可能会导致程序无响应。在这种情况下，线程就派上用处了。线程的主要目的是提高程序的运行性能。尽管使用多个线程可以提升整体性能，但与单个线程相比，多个线程使用总会引入额外的开销。如果多线程设计有误，实现某个功能时性能甚至比单线程的性能还差。所以在使用线程时评估好任务执行耗时，充分利用资源进行优化。 线程引入的开销有哪些?在考虑使用多线程时，并行带来的性能提升必须要大于并发导致的性能开销，否则不要使用多线程。具体的线程开销有三种1.上下文切换， 是指CPU从一个线程或进程切换到另一个线程或进程。 当线程执行时发生的阻塞越多，与CPU密集型的程序就会发生越多的上下文切换，从而增加线程的开销。2.内存同步，在使用volatile提供内存可见性时会使用一些特殊指令，即内存栅栏。内存栅栏可以刷新缓存，但是同样间接性的带来了性能上的影响，因为抑制了编译器的优化操作。在内存栅栏中，大多数操作是不能被重排序的。3.线程阻塞，线程的竞争会增加开销。在锁上发生竞争时，竞争失败的线程会阻塞。当线程无法获取某个锁或者线程等待或者产生I/O阻塞时，线程被挂起，这个过程包含两次额外的上下文切换。 怎样降低锁的竞争串行操作会降低可伸缩性，并且上下文切换时也会降低性能。在锁上发生竞争会导致这些问题，因此减小锁的竞争能够提高性能和可伸缩性。有三种方式可以降低锁的竞争程度：1.减小锁的持有时间，尽可能的缩短锁的持有时间，例如将与锁无关的代码移出代码块，尤其是开销较大的，以及可能被阻塞的操作。2.减小锁的粒度，降低单位时间内请求锁的次数，从而降低竞争的可能性。3.锁分段，将锁分解技术进一步扩展对一组独立对象上的锁进行分解。4.避免热点区。5.放弃使用独占锁。例如使用并发容器，读写锁，不可变对象以及原子变量。 小结程序的可伸缩性取决于所有代码中必须被串行执行的代码比例，我们可以通过以下方式来提高可伸缩性：减少锁的持有时间，降低锁的粒度，采用非独占式的锁或非阻塞锁来代替独占锁。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"线程优化","slug":"线程优化","permalink":"http://www.uuuup.vip/tags/线程优化/"}]},{"title":"合理设置Java线程池大小","slug":"concurrent/线程池大小设置","date":"2018-12-22T16:00:00.000Z","updated":"2019-01-27T16:58:00.564Z","comments":true,"path":"2018/12/23/concurrent/线程池大小设置/","link":"","permalink":"http://www.uuuup.vip/2018/12/23/concurrent/线程池大小设置/","excerpt":"","text":"设置Java线程池大小线程池大小设置取决于所部署的系统中包含的CPU， 内存。 必须分析计算环境，资源预算和任务的特性。 CPU密集型尽量使用较小的线程池，一般CPU核心数+1。因为CPU密集型任务CPU的使用率很高，若开过多的线程，只能增加线程上下文的切换次数，带来额外的开销。任务特性分为CPU密集型， IO密集型，混合密集型。对于CPU密集型， 在拥有N个CPU的处理器系统中，线程设置为 n + 1。 IO密集型可以使用较大的线程池，一般CPU核心数 2， IO密集型CPU使用率不高，可以让CPU等待IO的时候处理别的任务，充分利用CPU时间。对于IO密集型，线程设置为 最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ） CPU数目， 比如线程等待时间为 1s,而线程CPU时间为0.5s，假设当前CPU核心数为4核，则当前线程池大小为12。 在实际项目中可以通过1int cpuNum = Runtime.getRuntime().availableProcessors(); 获取CPU cpuNum数目。结论：线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://www.uuuup.vip/tags/线程池/"}]},{"title":"Java线程池的初始化","slug":"concurrent/线程池的初始化","date":"2018-12-22T16:00:00.000Z","updated":"2018-12-23T17:22:30.000Z","comments":true,"path":"2018/12/23/concurrent/线程池的初始化/","link":"","permalink":"http://www.uuuup.vip/2018/12/23/concurrent/线程池的初始化/","excerpt":"","text":"线程池初始化在之前文章中简单介绍了线程池的四种使用方式，在本节中将具体讲解它们的底层实现。 首先四种工具方法的实现方式：12345678910111213141516171819202122newFixedThreadPool是一个固定长度的线程池return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());newSingleThreadExecutor是一个单线程的线程池return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));newCachedThreadPool是一个可缓存的线程池return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());newScheduledThreadPool是一个固定长度的线程池return new ScheduledThreadPoolExecutor(corePoolSize);public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 其中每个工具类方法都会调用公用的构造器 ThreadPoolExecutor，实现方式如下：123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; 核心参数的含义：corePoolSize： 核心池的大小。默认情况下县城创建后线程池的大小为0，当任务来时创建线程去执行任务，当线程池的线程数量达到核心池数量时，就会把任务放到队列中等待线程执行。maximumPoolSize：线程池最大线程数，这表示线程池所能创建的最大线程数。keepAliveTime： 线程未执行任务时经过多长时间被回收。默认情况下只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用。但是但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0。unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性如下1234567TimeUnit.DAYS; //天TimeUnit.HOURS; //小时TimeUnit.MINUTES; //分钟TimeUnit.SECONDS; //秒TimeUnit.MILLISECONDS; //毫秒TimeUnit.MICROSECONDS; //微妙TimeUnit.NANOSECONDS; //纳秒 workQueue：一个阻塞队列，用来存储等待执行的任务，一般来说，这里的阻塞队列有以下几种选择：123ArrayBlockingQueue; 基于数组的先进先出队列，此队列创建时必须指定大小。LinkedBlockingQueue; 基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE。SynchronousQueue; 这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。 threadFactory：线程工厂类，有默认实现，如果有自定义的需要则需要自己实现ThreadFactory接口并作为参数传入。 handler：表示当拒绝处理任务时的策略，有以下四种取值：1234ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。（默认使用方式） ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 二种线程方法执行1.带返回值的线程提交123456public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); //返回一个FutureTask对象 execute(ftask); return ftask;&#125; 2.不带返回值的线程提交，交由线程池去执行1void execute(Runnable command); 线程方法关闭shutdown() 与 shutdownNow()shutdown 不会立即终止线程池，在不接收新的任务同时等待缓存队列中的任务执行完成后终止。shutdownNow 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。 举个例子：新建一个线程池测试带返回值的任务执行12345678910111213141516171819202122232425262728public class ThreadPoolExecutorTask &#123; public static void main(String[] args) &#123; int nThreads = 5; ExecutorService executorService = new ThreadPoolExecutor(nThreads, nThreads, 60L, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;()); try &#123; List&lt;Future&gt; futures = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; Future future = executorService.submit(new TaskResult()); futures.add(future); &#125; for (int j = 0; j &lt; futures.size(); j++) &#123; System.out.println(futures.get(j).get()); &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; executorService.shutdown(); &#125; &#125;&#125;class TaskResult implements Callable &#123; @Override public Object call() throws Exception &#123; return Thread.currentThread().getName() + \": 执行完毕\"; &#125;&#125; 执行结果：pool-1-thread-1: 执行完毕pool-1-thread-2: 执行完毕pool-1-thread-3: 执行完毕pool-1-thread-4: 执行完毕pool-1-thread-5: 执行完毕pool-1-thread-3: 执行完毕pool-1-thread-3: 执行完毕pool-1-thread-2: 执行完毕pool-1-thread-3: 执行完毕pool-1-thread-3: 执行完毕","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://www.uuuup.vip/tags/线程池/"}]},{"title":"github更改作者的提交信息","slug":"更改github作者信息","date":"2018-12-19T23:01:34.000Z","updated":"2018-12-19T18:36:16.075Z","comments":true,"path":"2018/12/20/更改github作者信息/","link":"","permalink":"http://www.uuuup.vip/2018/12/20/更改github作者信息/","excerpt":"","text":"问题发现github拉取代码分支后提交后贡献值不增加 解决办法执行第一步：git config --global user.email &quot;youremail@googl.com&quot;git config --global user.name &quot;your name&quot; 执行第二步：git clone --bare https://github.com/user/repo.gitcd repo.git 执行第三步： filter-branch --env-filter '12345678910111213141516OLD_EMAIL=&quot;your-old-email@example.com&quot; // 你的旧的email账号CORRECT_NAME=&quot;Your Correct Name&quot; // 你的新的用户名CORRECT_EMAIL=&quot;your-correct-email@example.com&quot; // 你的新的email账号if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot; export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;fiif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot; export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi&apos; --tag-name-filter cat -- --branches --tags 执行第四步：git push --force --tags origin &#39;refs/heads/*&#39; ok，至此作者信息修改完毕 此时本地仓库提交代码会失败，首先执行 更新：git pull origin master --allow-unrelated-histories","categories":[{"name":"git","slug":"git","permalink":"http://www.uuuup.vip/categories/git/"}],"tags":[{"name":"git filter-branch --env-filter","slug":"git-filter-branch-env-filter","permalink":"http://www.uuuup.vip/tags/git-filter-branch-env-filter/"}]},{"title":"Java线程池的四种使用方式","slug":"concurrent/Java线程池的四种使用方式","date":"2018-12-14T16:00:00.000Z","updated":"2019-01-27T16:58:00.578Z","comments":true,"path":"2018/12/15/concurrent/Java线程池的四种使用方式/","link":"","permalink":"http://www.uuuup.vip/2018/12/15/concurrent/Java线程池的四种使用方式/","excerpt":"","text":"Executor框架Executor 中常用的四种静态方法： 1.newSingleThreadExecutor是一个单线程的Executor，使用唯一的线程来执行任务。 2.newFixedThreadPool是一个固定长度的线程池，每当提交任务时就会创建线程，直到线程池最大数量，线程池的规模不再变化。 3.newCachedThreadPool是一个可缓存的线程池，线程池的规模不存在任何限制。 如果当前线程池的资源有空闲，那么将回收空闲资源。如果资源增加时需要线程，则向线程池添加线程。 4.newScheduledThreadPool是一个固定长度的线程池，并且以延迟的方式来执行任务。 123456789101112131415161718192021222324252627282930313233343536373839404142public class ExecutorTask &#123; public static void main(String[] args) &#123; // 1.newSingleThreadExecutor是一个单线程的Executor，使用唯一的线程来执行任务。 ExecutorService executorService1 = Executors.newSingleThreadExecutor(); executorService1.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"newSingleThreadExecutor is done\"); &#125; &#125;); executorService1.shutdown(); // 2.newFixedThreadPool是一个固定长度的线程池，每当提交任务时就会创建线程，直到线程池最大数量，线程池的规模不再变化。 ExecutorService executorService2 = Executors.newFixedThreadPool(10); executorService2.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"newFixedThreadPool is done\"); &#125; &#125;); executorService2.shutdown(); // 3.newCachedThreadPool是一个可缓存的线程池，线程池的规模不存在任何限制。 如果当前线程池的资源有空闲，那么将回收空闲资源。如果资源增加时需要线程，则向线程池添加线程。 ExecutorService executorService3 = Executors.newCachedThreadPool(); executorService3.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"newCachedThreadPool is done\"); &#125; &#125;); executorService3.shutdown(); // 4.newScheduledThreadPool是一个固定长度的线程池，并且以延迟的方式来执行任务。 ExecutorService executorService4 = Executors.newScheduledThreadPool(10); executorService4.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"newScheduledThreadPool is done\"); &#125; &#125;); executorService4.shutdown(); &#125;&#125;","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://www.uuuup.vip/tags/线程池/"}]},{"title":"FutureTask 配合 ConcurrentHashMap 使用","slug":"concurrent/FutureTask使用","date":"2018-12-10T16:00:00.000Z","updated":"2019-01-27T16:58:00.569Z","comments":true,"path":"2018/12/11/concurrent/FutureTask使用/","link":"","permalink":"http://www.uuuup.vip/2018/12/11/concurrent/FutureTask使用/","excerpt":"","text":"FutureTask介绍FutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，直接调用其run方法或者放入线程池执行，之后可以在外部通过FutureTask的get方法异步获取执行结果。 ConcurrentHashMap 见文章 ConcurrentHashMap的源码分析本章节利用 ConcurrentHashMap 与 FutureTask 构建在多线程环境中高效的获取数据结果缓存例如： 在多线程环境中对比 通过(ConcurrentHashMap 与 FutureTask) 和 通过 Map 获取人员积分 （此处积分用随机数代替） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ValidCacheTest &#123; private static final ConcurrentHashMap&lt;String, Future&lt;Integer&gt;&gt; concurrentHashMap = new ConcurrentHashMap&lt;String, Future&lt;Integer&gt;&gt;(); private static final Map map = new HashMap(); public static void main(String[] args) throws Exception &#123; ValidCacheTest validCacheTest = new ValidCacheTest(); String personID = \"123456\"; for (int i = 0; i &lt; 5000; i++) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Object o1 = validCacheTest.compute(personID); Object o2 = validCacheTest.computeMap(personID); System.out.println(\"使用concurrentHashMap人员积分为：\" + (Integer) o1); System.out.println(\"使用map人员积分为：\" + (Integer) o2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); thread.start(); &#125; &#125; public Object compute(String personID) throws Exception &#123; Future future = concurrentHashMap.get(personID); if (future == null) &#123; Callable callable = new Callable() &#123; @Override public Object call() throws Exception &#123; // 从数据库通过人员ID获取积分，这里暂用随机数 return new Random().nextInt(1000); &#125; &#125;; FutureTask futureTask = new FutureTask(callable); //putIfAbsent在放入数据时，如果存在重复的key，那么putIfAbsent不会放入值，线程安全 future = concurrentHashMap.putIfAbsent(personID, futureTask); if (future == null) &#123; future = futureTask; futureTask.run(); &#125; &#125; return future.get(); &#125; public Object computeMap(String personID) throws Exception &#123; Object object = map.get(personID); if (object == null) &#123; Object o = new Random().nextInt(1000); //putIfAbsent在放入数据时，如果存在重复的key，那么putIfAbsent不会放入值，线程不安全 object = map.putIfAbsent(personID, o); if (object == null) &#123; object = o; &#125; &#125; return object; &#125;&#125;测试结果：（多次执行任务发现使用map时获取的值在多线程中不一致，而concurrentHashMap中获取的值不变） 使用map人员积分为：648 使用concurrentHashMap人员积分为：622 使用map人员积分为：650 使用concurrentHashMap人员积分为：622 使用map人员积分为：650 使用concurrentHashMap人员积分为：622 使用map人员积分为：650 使用concurrentHashMap人员积分为：622 使用map人员积分为：650 小结 FutureTask在高并发环境下确保任务只执行一次，配合concurrentHashMap使用，支持高并发的同时确保线程安全性。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","permalink":"http://www.uuuup.vip/tags/ConcurrentHashMap/"},{"name":"FutureTask","slug":"FutureTask","permalink":"http://www.uuuup.vip/tags/FutureTask/"}]},{"title":"Java同步工具之CyclicBarrier","slug":"concurrent/CyclicBarrier","date":"2018-12-09T16:00:00.000Z","updated":"2019-01-27T16:58:00.561Z","comments":true,"path":"2018/12/10/concurrent/CyclicBarrier/","link":"","permalink":"http://www.uuuup.vip/2018/12/10/concurrent/CyclicBarrier/","excerpt":"","text":"Java并发之同步工具 CyclicBarrierCyclicBarrier循环屏障CyclicBarrier用于让一组线程运行并互相等待，直到共同到达一个公共屏障点 (common barrier point，又被称为同步点)，被屏障拦截的所有线程就会继续执行。 CyclicBarrier与CountDownLatch的功能非常类似。但一个CyclicBarrier实例在释放等待线程后可以继续使用。让下一批线程在屏障点等待。但CountDownLatch实例只能被使用一次。所以CyclicBarrier被称为循环 的 barrier。 CyclicBarrier类的用法构造方法 CyclicBarrier(int parties) 创建CyclicBarrier对象，parties 表示屏障拦截的线程数量。 CyclicBarrier(int parties, Runnable barrierAction) 创建 CyclicBarrier对象，该构造方法提供了一个Runnable参数，在一组线程中的最后一个线程到达之后，执行Runnable中的程序，再之后释放正在等待的线程。Runnable在屏障点上只运行一次。 方法 int await() 通知CyclicBarrier实例，当前线程已经到达屏障点，然后当前线程将被阻塞。 int await(long timeout, TimeUnit unit)指定当前线程被阻塞的时间。 int getNumberWaiting()返回当前在屏障处等待的线程数。 int getParties()返回CyclicBarrier的需要拦截的线程数。 boolean isBroken() 查询此屏障是否处于损坏状态。 void reset() 将屏障重置为其初始状态。 例如：所有的线程都到达共同屏障点后执行数据，可以用于分类数据求总和12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; int parties = 5; CyclicBarrier cyclicBarrier = new CyclicBarrier(parties, new Runnable() &#123; @Override public void run() &#123; System.out.println(currentThread().getName() + \"所有线程执行完毕，结束\"); &#125; &#125;); for (int i = 0; i &lt; parties; i++) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(currentThread().getName() + \"准备执行\"); try &#123; Thread.sleep(1000); System.out.println(currentThread().getName() + \" 开始执行，等待别的线程执行完毕\"); cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(currentThread().getName() + \" 执行完毕，等待别的线程执行完毕\"); &#125; &#125; &#125;); thread.start(); &#125; &#125;运行结果：Thread-0准备执行Thread-4准备执行Thread-1准备执行Thread-3准备执行Thread-2准备执行Thread-4 开始执行，等待别的线程执行完毕Thread-3 开始执行，等待别的线程执行完毕Thread-0 开始执行，等待别的线程执行完毕Thread-2 开始执行，等待别的线程执行完毕Thread-1 开始执行，等待别的线程执行完毕Thread-3所有线程执行完毕，结束Thread-3 执行完毕，等待别的线程执行完毕Thread-0 执行完毕，等待别的线程执行完毕Thread-4 执行完毕，等待别的线程执行完毕Thread-1 执行完毕，等待别的线程执行完毕Thread-2 执行完毕，等待别的线程执行完毕","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"CyclicBarrier","slug":"CyclicBarrier","permalink":"http://www.uuuup.vip/tags/CyclicBarrier/"}]},{"title":"Java同步工具之CountDownLatch","slug":"concurrent/CountDownLatch","date":"2018-12-06T16:00:00.000Z","updated":"2019-01-27T16:52:13.586Z","comments":true,"path":"2018/12/07/concurrent/CountDownLatch/","link":"","permalink":"http://www.uuuup.vip/2018/12/07/concurrent/CountDownLatch/","excerpt":"","text":"Java并发之同步工具 CountDownLatchCountDownLatch 概念CountDownLatch 是一种灵活的闭锁实现，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器初始化为一个正整数，表示需要等待的事件数量。countDown 方法递减计数器，表示事件发生。而await方法等待计数器达到零，这表示所有需要等待的事件都已经发生，可以执行自定义的操作。如果计数器的值非零，那么await会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。 CountDownLatch类的用法构造方法：CountDownLatch(int count) 构造方法参数指定了计数的次数。 方法：void await() 使当前线程在锁存器倒计数至0之前一直等待，除非线程被中断。boolean await(long timeout, TimeUnit unit) 使当前线程在锁存器倒计数至0之前一直等待，除非线程被中断或超出了指定的等待时间。void countDown() 计数减1。当计数为0，则释放所有等待的线程。long getCount() 返回当前计数。String toString() 返回标识此锁存器及其状态的字符串。 例如：使用了两个闭锁，分别表示起始门和结束门，当起始门的值为零时触发结束门的countDown，能使主线程高效的等待所有工作执行完成。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; int nThreads = 5; CountDownLatch countDownLatchStart = new CountDownLatch(1); CountDownLatch countDownLatchEnd = new CountDownLatch(nThreads); for (int i = 0; i &lt; nThreads; i++) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; synchronized (countDownLatchEnd) &#123; try &#123; System.out.println(currentThread().getName() + \" countDownLatchStart start...\"); super.run(); countDownLatchStart.await(); System.out.println(currentThread().getName() + \" countDownLatchStart end...\"); &#125; catch (Exception e) &#123; &#125; finally &#123; countDownLatchEnd.countDown(); System.out.println(\"current countDown count is...\" + countDownLatchEnd.getCount()); &#125; &#125; &#125; &#125;; thread.start(); &#125; long startTime = System.currentTimeMillis(); countDownLatchStart.countDown(); countDownLatchEnd.await(); long endTime = System.currentTimeMillis(); System.out.println(\"countDownLatchEnd end...cost(\" + (endTime - startTime) + \")\"); &#125;&#125;//运行结果：Thread-0 countDownLatchStart start...Thread-0 countDownLatchStart end...current countDown count is...4Thread-4 countDownLatchStart start...Thread-4 countDownLatchStart end...current countDown count is...3Thread-3 countDownLatchStart start...Thread-3 countDownLatchStart end...current countDown count is...2Thread-2 countDownLatchStart start...Thread-2 countDownLatchStart end...current countDown count is...1Thread-1 countDownLatchStart start...Thread-1 countDownLatchStart end...current countDown count is...0countDownLatchEnd end...cost(2) CountDownLatch的不足CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"CountDownLatch","slug":"CountDownLatch","permalink":"http://www.uuuup.vip/tags/CountDownLatch/"}]},{"title":"Java同步工具之Semaphore","slug":"concurrent/Semaphore","date":"2018-12-06T16:00:00.000Z","updated":"2019-01-27T16:58:00.576Z","comments":true,"path":"2018/12/07/concurrent/Semaphore/","link":"","permalink":"http://www.uuuup.vip/2018/12/07/concurrent/Semaphore/","excerpt":"","text":"Java并发之同步工具 SemaphoreSemaphore信号量Semaphore 用于控制线程并发数，Semaphore 可以控制同时访问资源的线程个数，实现一个文件允许访问的并发数。Semaphore维护了一个许可集，当调用acquire() 方法获取到许可时即可进入，无法获取许可的线程阻塞到有许可（或者直到连接中断或者连接超时）。而 release() 表示释放一个许可。可以把Semaphore看成是一种共享锁。Semaphore允许同一时间多个线程同时访问临界区。 Semaphore类的用法常用方法：public void acquire() 获取许可。 public boolean tryAcquire() 尝试获取许可。 public boolean tryAcquire(long timeout, TimeUnit unit) 在指定的时间内尝试地获取1个许可。 public void release() 释放许可。该方法一般调用于finally块中。int availablePermits() 返回此信号量中当前可用的许可数。 例如： 在多线程中展示信号量的可用许可，为了准确测试当前许可数量，需要同步锁住semaphore 对象进行测试。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class SemaphoreDemo &#123; public static void main(String[] args) &#123; int permits = 4; Semaphore semaphore = new Semaphore(permits); for (int i = 0; i &lt; permits; i++) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; synchronized (semaphore) &#123; try &#123; System.out.println(\"当前可用许可 \" + (semaphore.availablePermits())); semaphore.acquire(); super.run(); System.out.println(currentThread().getName() + \" 获取一个许可\"); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(\"当前可用许可 \" + (semaphore.availablePermits())); System.out.println(currentThread().getName() + \" 释放一个许可\"); semaphore.release(); System.out.println(\"当前可用许可 \" + (semaphore.availablePermits())); &#125; &#125; &#125; &#125;; thread.start(); &#125; &#125;&#125;输出结果：当前可用许可 4Thread-0 获取一个许可当前可用许可 3Thread-0 释放一个许可当前可用许可 4Thread-3 获取一个许可当前可用许可 3Thread-3 释放一个许可当前可用许可 4Thread-2 获取一个许可当前可用许可 3Thread-2 释放一个许可当前可用许可 4Thread-1 获取一个许可当前可用许可 3Thread-1 释放一个许可","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"Semaphore","slug":"Semaphore","permalink":"http://www.uuuup.vip/tags/Semaphore/"}]},{"title":"Volatile关键字解析","slug":"concurrent/Volatile","date":"2018-11-28T16:00:00.000Z","updated":"2019-01-27T16:58:00.573Z","comments":true,"path":"2018/11/29/concurrent/Volatile/","link":"","permalink":"http://www.uuuup.vip/2018/11/29/concurrent/Volatile/","excerpt":"","text":"前言 在介绍Volatile之前，先简单了解一下java内存模型。在java内存模型中规定，简称为JMM。 主内存和工作内存主内存存放数据共享的区域，数据可以在线程中共享，包括实例变量，静态变量等。线程在工作时，需要将主存中的数据拷贝到工作内存，线程之间的数据不可以共享，并且不能直接操作主内存或者其他线程工作内存中的数据。这里所提到的主内存可以简单认为是堆内存，而工作内存可以简单认为是栈内存。 工作内存每个线程有自己的工作内存，各个线程之间不支持数据资源共享，线程使用的变量是从主内存的副本拷贝，线程所有的数据操作必须在工作内存中，无法直接获取主内存的数据，线程之间的变量值传递必须通过主内存来完成。 Volatile 原理 Java语言提供了一种稍弱的同步机制，即volatile变量，确保变量的更新操作通知到其他线程。当线程变量被volatile修饰后，编译器会自动识别该变量属于线程共享，因此在读取volatile修饰的变量时总是读取最新的值。 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 内存可见性 变量在被volatile修饰后更改变量的值会立即被写回主存，同时会使其他线程工作内存的旧值失效，新值对于其他线程是可见的，因为volatile修饰的变量在每个线程中使用前都会去主内存中获取最新的值。 虽然volatile修饰的值每次都会被线程获取到，但是并不能保证线程并发的安全性。因为忽略了原子性，volatile在执行时并不能保证原子性，对变量的操作可能就是很简单的 i+=1,但是底层需要多条字节码操作才能完成，在并发情况并不能保证原子性。 禁止指令重排序优化 指令重排序是指CPU在正确处理指令依赖(数据依赖)并且保障程序执行得到正确结果的情况下，调整代码的执行顺序，允许将多条指令不按照程序规定顺序分开发送给各相应电路单元处理。需要注意的是指令重排序不会影响到代码在单线程环境下的执行，会影响到多线程并发情况下执行的正确性。 使用条件如果让volatile保证原子性，必须符合以下两条规则：1.运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；2.变量不需要与其他的状态变量共同参与不变约束； 先行发生原则先行发生（happens-before）是判断数据是否存在竞争、线程是否安全的主要依据。如果A操作在B操作之前完成，那么B将观察到A执行的结果。Java 内存模型中存在着一些天然的先行发生关系：1). 程序次序规则：在一个线程内，操作分先后，控制流顺序。2). 管程锁定规则：一个unlock释放锁的操作先行发生于后面对同一个锁的lock加锁操作。2). volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。2). 线程启动规则：Thread的start()方法先发生于对这个线程的所有操作。5). 线程终止规则：现成的所有操作都先行发生于对此线程的终止操作。6). 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。7). 对象终结规则：一个对象的初始化完成先行发生于它的finalize() 方法。8). 传递性：如果A操作先行发生于B操作，操作B先行发生于C操作，那么可以得出A操作先发生于C操作。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"Volatile","slug":"Volatile","permalink":"http://www.uuuup.vip/tags/Volatile/"}]},{"title":"线程与进程详解","slug":"concurrent/线程与进程详解","date":"2018-10-22T16:00:00.000Z","updated":"2019-01-27T16:58:00.583Z","comments":true,"path":"2018/10/23/concurrent/线程与进程详解/","link":"","permalink":"http://www.uuuup.vip/2018/10/23/concurrent/线程与进程详解/","excerpt":"","text":"进程的定义 进程是指处于运行过程中的程序，并且具有一定的独立功能。进程是系统进行资源分配和调度的一个单位。 当程序进入内存运行时，即为进程。几乎所有的操作系统都支持多任务运行，而每个任务就是一个进程。 当一个进程运行时，内部可以支持多个执行流程，而每个流程就是一个线程。 线程的定义线程的介绍线程也称为轻型进程，因为线程只能在单个进程的作用域中使用，所以创建线程比创建进程要廉价得多。 线程是进程的组成部分，一个进程可以拥有多个线程，而一个线程只能属于单个进程。线程有自己的独立资源，比如栈，程序计数器，寄存器。 线程可以与当前进程中的其他线程共享进程资源。 线程的特点线程之间可以协作完成任务。 线程之间是独立运行的，相互之间互不影响。 线程之间执行属于抢占式的，也就是说，线程的执行顺序是不一致的。 线程之间可以并发执行。 多线程的实现方式三种实现方式包括继承Thread， 实现Runnable, 使用ExecutorService、Callable、Future实现有返回结果的多线程。 1234567891011121314151617181920212223242526272829303132public class ThreadTest extends Thread &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i ++) &#123; System.out.println(\"Thread,线程:::\" + Thread.currentThread().getName() + \" 正在执行\"); &#125; &#125;&#125;class RunnableTest implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i ++) &#123; System.out.println(\"Runnable,线程:::\" + Thread.currentThread().getName() + \" 正在执行\"); &#125; &#125;&#125;class CallableDemo implements Callable &#123; @Override public Object call() throws Exception &#123; for (int i = 0; i &lt; 5; i ++) &#123; System.out.println(\"Callable,线程:::\" + Thread.currentThread().getName() + \" 正在执行\"); &#125; return \"Callable,线程:::\" + Thread.currentThread().getName() + \" 正在执行\"; &#125;&#125; 第一种继承Thread类1234ThreadTest threadTest = new ThreadTest();threadTest.start();ThreadTest threadTest1 = new ThreadTest();threadTest1.start(); 继承Thread的运行结果 12345678910Thread,线程:::Thread-0 正在执行Thread,线程:::Thread-1 正在执行Thread,线程:::Thread-0 正在执行Thread,线程:::Thread-1 正在执行Thread,线程:::Thread-0 正在执行Thread,线程:::Thread-1 正在执行Thread,线程:::Thread-0 正在执行Thread,线程:::Thread-0 正在执行Thread,线程:::Thread-1 正在执行Thread,线程:::Thread-1 正在执行 第二种实现Runnable接口123456//实现多线程RunnableTest runnableTest = new RunnableTest();Thread threadTest2 = new Thread(runnableTest);Thread threadTest3 = new Thread(runnableTest);threadTest2.start();threadTest3.start(); 实现Runnable接口的运行结果 12345678910Runnable,线程:::Thread-0 正在执行Runnable,线程:::Thread-1 正在执行Runnable,线程:::Thread-0 正在执行Runnable,线程:::Thread-1 正在执行Runnable,线程:::Thread-0 正在执行Runnable,线程:::Thread-1 正在执行Runnable,线程:::Thread-0 正在执行Runnable,线程:::Thread-1 正在执行Runnable,线程:::Thread-0 正在执行Runnable,线程:::Thread-1 正在执行 第三种使用ExecutorService、Callable、Future实现有返回结果的多线程12345678ExecutorService executorService = Executors.newFixedThreadPool(2); CallableDemo callableDemo1 = new CallableDemo(); CallableDemo callableDemo2 = new CallableDemo(); Future future1 = executorService.submit(callableDemo1); Future future2 = executorService.submit(callableDemo2); future1.get(); //如果调用返回Future对象的get()方法，会阻塞直到计算完成 future2.get(); executorService.shutdown(); 使用ExecutorService、Callable、Future 的运行结果 12345678910Callable,线程:::pool-1-thread-2 正在执行Callable,线程:::pool-1-thread-1 正在执行Callable,线程:::pool-1-thread-1 正在执行Callable,线程:::pool-1-thread-1 正在执行Callable,线程:::pool-1-thread-1 正在执行Callable,线程:::pool-1-thread-2 正在执行Callable,线程:::pool-1-thread-1 正在执行Callable,线程:::pool-1-thread-2 正在执行Callable,线程:::pool-1-thread-2 正在执行Callable,线程:::pool-1-thread-2 正在执行","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://www.uuuup.vip/categories/Java并发/"}],"tags":[{"name":"进程","slug":"进程","permalink":"http://www.uuuup.vip/tags/进程/"},{"name":"线程","slug":"线程","permalink":"http://www.uuuup.vip/tags/线程/"}]},{"title":"LinkedList的源码分析","slug":"LinkedList","date":"2018-09-15T23:01:34.000Z","updated":"2018-12-09T14:08:29.360Z","comments":true,"path":"2018/09/16/LinkedList/","link":"","permalink":"http://www.uuuup.vip/2018/09/16/LinkedList/","excerpt":"","text":"LinkedList 简介LinkedList 是继承于AbstractSequentialList的双向链表， 它可以被当做堆栈，队列或双端队列使用。LinkedList 实现了List接口， 能对它进行队列操作。LinkedList 实现了Cloneable接口， 覆盖了函数clone(), 支持克隆。LinkedList 实现了Deque接口， 能将 LinkedList当做双端队列使用。LinkedList 实现了Serializable接口，意味着支持序列化， 便于在网络中传输和保存。 12345public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; &#125; LinkedList 是采用链表的方式来实现List接口的,它本身有自己特定的方法， 如: addFirst(),addLast(),getFirst(),getLast(),removeFirst()，removeFirst()，removeLast()。 元素的插入与获取addFirst() 和 addLast()直接插入头部元素 和 尾部元素实现方式1234567891011121314151617181920212223242526272829public void addFirst(E e) &#123; linkFirst(e);&#125;private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //构造头部对象 first = newNode; if (f == null) //如果f为空，则first == last last = newNode; else f.prev = newNode; //否则 头节点为newNode size++; modCount++;&#125;public void addLast(E e) &#123; linkLast(e); &#125;//默认的添加方式也是由此方法实现 void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //构造尾部对象 last = newNode; if (l == null) //如果l为空，则first == last first = newNode; else l.next = newNode; //否则，尾节点为newNode size++; modCount++;&#125; getFirst() 和 getLast()直接获取头部元素 和 尾部元素实现方式123456789101112public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125; public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; LinkedList 查找元素 1234567891011121314151617181920public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; //判断index 是否为 list size 的 一半 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) // 从 0 ~ index 中循环遍历 x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) // 从 index ~ zize - 1 中遍历 x = x.prev; return x; &#125;&#125; 由此得出结论： LinkedList 采用了链表结构，所以在添加和删除方面效率高，查找比较慢 元素的删除removeFirst() 和 removeLast()LinkedList 移除首个元素 和 移除最后一个元素123456789101112131415161718192021222324252627282930313233//removeFirst 主要实现private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; //将当前元素清空 f.next = null; // help GC first = next; //指针后移 if (next == null) last = null; else next.prev = null; //将节点prev置空 size--; modCount++; return element;&#125;//removeLast 主要实现private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; //将当前元素清空 l.prev = null; // help GC last = prev; //指针前移 if (prev == null) first = null; else prev.next = null; //将节点next置空 size--; modCount++; return element;&#125; 主要移除元素底层实现(根据下标移除，根据元素移除)链表结构图如下：将链表重新组装12345678910111213141516171819202122232425E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; //获取当前节点下一节点 final Node&lt;E&gt; prev = x.prev; //获取当前节点上一节点 if (prev == null) &#123; //如果上一节点为空，则首节点下一节点 first = next; &#125; else &#123; //将上一节点的下一节点替换为当前元素的下一节点 prev.next = next; x.prev = null; &#125; if (next == null) &#123; //如果下一节点为空，则尾节点上一节点 last = prev; &#125; else &#123; //将下一节点的上一节点替换为当前元素的下一节点 next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; LinkedList 用作堆栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * LinkedList 实现堆栈的先进后出 */public class StackDemo &#123; private LinkedList linkedList = new LinkedList&lt;&gt;(); /** * 将每次添加的元素都添加到第一个位置 * * @param o */ public void push(Object o) &#123; linkedList.addFirst(o); &#125; /** * 取出第一个元素但是不删除元素 * * @return */ public Object peek() &#123; return linkedList.peek(); &#125; /** * 取出并移除元素 * * @return */ public Object poll() &#123; return linkedList.poll(); &#125; /** * 获取元素个数 * * @return */ public int size() &#123; return linkedList.size(); &#125; /** * 判断堆栈是否为空 * (即判断 linkedList是否为空) * * @return */ public boolean isEmpty() &#123; return linkedList.isEmpty(); &#125; public static void main(String[] args) &#123; StackDemo stackDemo = new StackDemo(); stackDemo.push(\"1\"); stackDemo.push(\"2\"); stackDemo.push(\"3\"); stackDemo.push(\"4\"); stackDemo.push(\"5\"); System.out.println(\"取出第一个元素：：：：\" + stackDemo.peek()); System.out.println(\"取出第一个元素：：：：\" + stackDemo.poll()); while (!stackDemo.isEmpty()) &#123; System.out.print(stackDemo.poll()); &#125; &#125;&#125; LinkedList 用作堆栈 输出结果为1234567891011插入第1个元素,值为 1插入第2个元素,值为 2插入第3个元素,值为 3插入第4个元素,值为 4插入第5个元素,值为 5取出第一个元素 5取出第一个元素 5输出顺序为 4输出顺序为 3输出顺序为 2输出顺序为 1 LinkedList 用作队列123456789101112131415161718192021/** * LinkedList 实现先进先出队列 */public class QueueDemo &#123; public static void main(String[] args) &#123; Queue queue = new LinkedList(); //offer()方法是往队列尾部加入元素 for (int i = 0; i &lt; 5; i++) &#123; queue.offer(i + 1); System.out.println(\"插入第\"+ (i + 1) +\"个元素,\" + \"值为 \" + (i + 1)); &#125; while (!queue.isEmpty()) &#123; System.out.println(\"输出顺序 \" + queue.poll()); &#125; &#125;&#125; 输出结果为12345678910插入第1个元素,值为 1插入第2个元素,值为 2插入第3个元素,值为 3插入第4个元素,值为 4插入第5个元素,值为 5输出顺序 1输出顺序 2输出顺序 3输出顺序 4输出顺序 5","categories":[{"name":"JAVA 集合","slug":"JAVA-集合","permalink":"http://www.uuuup.vip/categories/JAVA-集合/"}],"tags":[{"name":"LinkedList","slug":"LinkedList","permalink":"http://www.uuuup.vip/tags/LinkedList/"}]},{"title":"LinkedHashMap的源码分析","slug":"LinkedHashMap","date":"2018-09-14T23:01:34.000Z","updated":"2018-12-09T14:08:29.345Z","comments":true,"path":"2018/09/15/LinkedHashMap/","link":"","permalink":"http://www.uuuup.vip/2018/09/15/LinkedHashMap/","excerpt":"","text":"LinkedHashMap 简介 LinkedHashMap 继承了 HashMap, 实现了map接口。 所以 LinkedHashMap 包含了 HashMap 的所有功能， 它是一个关联数组，线程不安全，并且key值，value值允许为空。LinkedHashMap 与 HashMap 不同之处是它支持写入顺序排序，访问顺序排序。 顺序展示效果示例代码 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Map map = new LinkedHashMap(); map.put(\"1\", 1); map.put(\"2\", 2); map.put(\"3\", 3); map.put(\"4\", 4); map.put(\"5\", 5); Iterator iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); System.out.println(entry.getKey() + \"::\" + entry.getValue()); &#125; System.out.println(\"accessOrder 设置为 true\"); Map mapOrder = new LinkedHashMap(15, 0.75f, true); mapOrder.put(\"1\", 1); mapOrder.put(\"2\", 2); mapOrder.put(\"3\", 3); mapOrder.put(\"4\", 4); mapOrder.put(\"5\", 5); mapOrder.get(\"1\"); Iterator iterator1 = mapOrder.entrySet().iterator(); while (iterator1.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator1.next(); System.out.println(entry.getKey() + \"::\" + entry.getValue()); &#125;&#125;返回的结果如下： 写入顺序排序1::12::23::34::45::5accessOrder 设置为 true访问顺序排序2::23::34::45::51::1 带着疑问剖析源码，LinkedHashMap的构造函数有五种：123456789101112131415161718192021222324252627282930//默认是false，则迭代时输出的顺序是插入节点的顺序。若为true，则输出的顺序是按照访问节点的顺序。final boolean accessOrder;//指定初始化时的容量，和扩容的加载因子public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false;&#125;//指定初始化时的容量public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125;public LinkedHashMap() &#123; super(); accessOrder = false;&#125;//利用另一个Map 来构建public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; super(); accessOrder = false; putMapEntries(m, false);&#125;//指定初始化时的容量，和扩容的加载因子，以及迭代输出节点的顺序public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 构造函数和HashMap相比，就是增加了一个accessOrder参数。用于控制迭代时的节点顺序。 LinkedHashMap的添加在LinkedHashMap中没有重写HashMap的put方法，但是重写了HashMap中的newNode 方法，在每次构建新节点时，通过linkNodeLast(p)，将新节点链接在内部双向链表的尾部。源码如下：123456789101112131415161718Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; //在构建新节点时，构建的是`LinkedHashMap.Entry` 不再是`Node`. LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125;//每次插入数据是插入到尾节点，并且把方插入的节点的before设置为lastprivate void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; LinkedHashMap的删除LinkedHashMap也没有重写remove()方法，因为它的删除逻辑和HashMap并无区别。重点在于LinkedHashMap 重写了 afterNodeRemoval方法。12345678910111213void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null;//待删除节点 p 的前置后置节点都置空 if (b == null) head = a; else b.after = a; //重新关联b的after节点 if (a == null) tail = b; else a.before = b; //重新关联a的before节点 &#125; LinkedHashMap的查找LinkedHashMap 重写了 get() 和 getOrDefault() 方法。对比HashMap的实现可以发现只是增加了在成员变量(构造函数时赋值)accessOrder = true 的情况下会调用 afterNodeAccess() 方法。1234567891011121314151617181920212223242526272829303132333435363738394041public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125;public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return defaultValue; if (accessOrder) afterNodeAccess(e); return e.value;&#125;//此方法的目的是将不是尾部的元素并且accessOrder = true的节点e移动至内部的双向链表的尾部void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; //将p的设置为尾节点 if (b == null) // 如果p的前置节点为null，则p以前是头节点，所以更新现在的头节点为p的后置节点a head = a; else //否则更新b的后置节点为a b.after = a; if (a != null) // 如果p的后置节点不为null， 则更新a的前置节点为b a.before = b; else // 如果p的后置节点为null，则p就是尾节点，更新last 引用为b last = b; if (last == null) //如果尾节点为空，则链表中只有一个节点 head = p; else &#123; // 否则更新更新p的前置节点为原尾节点last，last的后置节点为p p.before = last; last.after = p; &#125; tail = p;//尾节点的引用赋值成p ++modCount; &#125;&#125;","categories":[{"name":"JAVA 集合","slug":"JAVA-集合","permalink":"http://www.uuuup.vip/categories/JAVA-集合/"}],"tags":[{"name":"LinkedHashMap","slug":"LinkedHashMap","permalink":"http://www.uuuup.vip/tags/LinkedHashMap/"}]},{"title":"HashSet的源码分析","slug":"HashSet","date":"2018-09-13T23:01:34.000Z","updated":"2018-12-19T18:35:11.919Z","comments":true,"path":"2018/09/14/HashSet/","link":"","permalink":"http://www.uuuup.vip/2018/09/14/HashSet/","excerpt":"","text":"HashSet 简介HashSet 是一个没有重复元素的集合。它是由 HashMap 实现的， 无序且允许空值。HashSet 是非线程同步的，没有提供数据访问保护，在多线程环境中容易导致多个线程更改数据后造成数据脏读。 HashSet 的添加方法12345678//map是一个HashMap&lt;E, Object&gt;对象，HashSet是由一个HashMap实例支持的private transient HashMap&lt;E,Object&gt; map;//PRESENT是一个static final Object对象，用来作为HashMap中的value值。private static final Object PRESENT = new Object();//熟悉hashmap的实现方式的话很容易理解put方法，对象作为key值，不允许重复，value使用 PRESENT。 public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; HashSet 的查找方法1234//如果此set包含指定元素，则返回 truepublic boolean contains(Object o) &#123; return map.containsKey(o);&#125; HashSet 的清空与移除方法 123456789//如果指定元素存在于此set中，则将其移除public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125;//从此set中移除所有元素public void clear() &#123; map.clear();&#125; HashSet 的遍历方式12345678910Set set = new HashSet();set.add(\"!\");set.add(\"a\");set.add(\"1\");Iterator iterator = set.iterator();//通过keyset的方式获取key值集合的迭代器while (iterator.hasNext()) &#123; String key = (String) iterator.next(); System.out.println(key);&#125;","categories":[{"name":"JAVA 集合","slug":"JAVA-集合","permalink":"http://www.uuuup.vip/categories/JAVA-集合/"}],"tags":[{"name":"HashSet","slug":"HashSet","permalink":"http://www.uuuup.vip/tags/HashSet/"}]},{"title":"HashMap的源码分析","slug":"HashMap","date":"2018-09-12T23:01:34.000Z","updated":"2018-12-09T14:08:29.351Z","comments":true,"path":"2018/09/13/HashMap/","link":"","permalink":"http://www.uuuup.vip/2018/09/13/HashMap/","excerpt":"","text":"HashMap 简介HashMap 是一个散列表， 它存储的内容是键值对（key - value）映射。HashMap 继承于 AbstractMap， 实现了Map， Cloneable，Serializable 接口。HashMap 不是线程安全的， 不适用于多线程中， 此外，HashMap中的映射不是有序的。HashMap 里面是一个数组，然后数组中每个元素是一个单项链表。图中Entry 包含四个属性，key，value，hash 值和用于单项链表的next。 重要参数capacity 和 loadFactor。capacity 当前数组容量，始终保持 2^n，默认值为 1&lt;&lt;4，最大为 1&lt;&lt;16, 可以扩容，扩容后数组大小为当前的 2 倍。loadFactor 负载因子，默认为 0.75。threshold 扩容的阈值，等于 capacity * loadFactor。123static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f; HashMap 的 put 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;//第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置 else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //首先，判断该位置的第一个数据和我们要插入的数据，key 是不是\"相等\"，如果是，取出这个节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 如果该节点是代表红黑树的节点，调用红黑树的插值方法 else &#123; // 到这里，说明数组该位置上是一个链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个 // 会触发下面的 treeifyBin，也就是将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // e!=null 说明存在旧值的key与要插入的key\"相等\" // 对于我们分析的put操作，下面这个 if 其实就是进行 \"值覆盖\"，然后返回旧值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125;接下来看 hashmap 的 resize 方法final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候 newCap = oldThr; else &#123; // 对应使用 new HashMap() 初始化后，第一次 put 的时候 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 用新的数组大小初始化新的数组 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; HashMap 的 get方法1.计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)2.判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步3.判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步4.遍历链表，直到找到相等(==或equals)的 key 1234567891011121314151617181920212223public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; 1 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) 2 return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) 3 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; 4 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125;","categories":[{"name":"JAVA 集合","slug":"JAVA-集合","permalink":"http://www.uuuup.vip/categories/JAVA-集合/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://www.uuuup.vip/tags/HashMap/"}]},{"title":"ConcurrentHashMap的源码分析","slug":"ConcurrentHashMap","date":"2018-09-11T23:01:34.000Z","updated":"2018-12-09T14:08:29.354Z","comments":true,"path":"2018/09/12/ConcurrentHashMap/","link":"","permalink":"http://www.uuuup.vip/2018/09/12/ConcurrentHashMap/","excerpt":"","text":"ConcurrentHashMap 简介 正是由于HashMap 不是线程安全的，所以大佬给我们带来了 线程安全的ConcurrentHashMap。 本文的分析的源码是JDK8的版本，与JDK7的版本有很大的差异，java7中 ConcurrentHashMap 由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。 它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用CAS算法。它沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想， 但是为了做到并发，又增加了很多辅助的类，例如TreeBin，Traverser等对象内部类。123456789101112131415161718192021222324252627282930hashmap 的 Node 类static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125;&#125;concurrentHashMap 的 Node 类static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next; Node(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.val = val; this.next = next; &#125;&#125; 其中的concurrentHashMap的 val next 都用了 volatile 修饰，保证了元素可见性。 concurrentHashMap的添加方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); (1). 根据 key 计算出 hashcode 。 int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) (2). 判断是否需要进行初始化。 tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; (3). 根据key的hash值和容器的容量减一后进行与运算定位。如果为空就尝试使用cas插入数据 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED) (4). 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。 tab = helpTransfer(tab, f); else &#123; V oldVal = null; synchronized (f) &#123; (5). 如果都不满足，则利用 synchronized 锁写入数据。 if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; //链表节点 binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; //树节点，与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode. Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); (6). 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。 if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null;&#125; concurrentHashMap 定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。 12345678910111213141516@SuppressWarnings(\"unchecked\")此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125;此函数用于比较tab数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123; return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125;利用volatile方法设置节点位置的值static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123; U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);&#125; concurrentHashMap的获取方法12345678910111213141516171819public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; (1). 根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。 if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) (2). 如果是红黑树那就按照树的方式获取值。 return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123; (3). 都不满足那就按照链表的方式遍历获取值。 if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null; &#125;","categories":[{"name":"JAVA 集合","slug":"JAVA-集合","permalink":"http://www.uuuup.vip/categories/JAVA-集合/"}],"tags":[{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","permalink":"http://www.uuuup.vip/tags/ConcurrentHashMap/"}]},{"title":"ArrayList/Vector的源码分析","slug":"ArrayList","date":"2018-09-11T09:01:34.000Z","updated":"2018-12-09T14:08:29.364Z","comments":true,"path":"2018/09/11/ArrayList/","link":"","permalink":"http://www.uuuup.vip/2018/09/11/ArrayList/","excerpt":"","text":"ArrayListArrayList 是动态数组，其实就是Array的复杂版本，它提供了动态增加和减少元素的功能，实现了List，RandomAccess, Collection接口，ArrayList不是线程安全的，建议在单线程中使用ArrayList。 ArrayList 包含两个重要属性分别是： 12345678910/*** elementData；* transient 关键字修饰表示防止此字段被序列化* 避免了浪费资源去存储没有的数据* size:* elementData中已存放的元素的个数，注意：不是elementData的容量* */transient Object[] elementData;private int size; 因为 elementData无法被序列化， 所以ArrayList 的序列化和反序列化依赖writeObject 和 readObject方法来实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; /** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 往ArrayList 中添加元素单个元素有两种方式第一种：将单个元素添加到尾部，并将size + 1。123456789101112131415161718192021222324/** * 向elementData中添加元素 */public boolean add(E var1) &#123; this.ensureCapacityInternal(this.size + 1);//确保对象数组elementData有足够的容量，可以将新加入的元素e加进去 this.elementData[this.size++] = var1;//加入新元素e，size加1 return true;&#125;/** * 确保数组的容量足够存放新加入的元素，若不够，要扩容 */public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length;//获取数组大小（即数组的容量） //当数组满了，又有新元素加入的时候，执行扩容逻辑 if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3) / 2 + 1;//新容量为旧容量的1.5倍+1 if (newCapacity &lt; minCapacity)//如果扩容后的新容量还是没有传入的所需的最小容量大或等于（主要发生在addAll(Collection&lt;? extends E&gt; c)中） newCapacity = minCapacity;//新容量设为最小容量 elementData = Arrays.copyOf(elementData, newCapacity);//复制新容量 &#125;&#125; 第二种：将单个元素添加到指定位置。12345678910public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1);//确保对象数组elementData有足够的容量，可以将新加入的元素e加进去 System.arraycopy(elementData, index, elementData, index + 1, size - index);//复制数组，将值往后移动 elementData[index] = element; size++;&#125; 12345678910/*** 添加元素时判断elementData是否为空，为空则设置elementData的大小为10*/private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; 由此可见两种添加方式前者比后者节省资源消耗。 VectorVector 也是实现于List接口，底层数据结构和ArrayList类似，也是动态数组存放数据，不过是在 add() 方法的时候使用 synchronized 进行同步写数据，与ArrayList不同的是Vector 线程安全，但是开销较大，所以 Vector 是一个同步容器并不是一个并发容器。 123456789101112131415161718192021222324/*** 在对象数组中尾部添加单个元素和在指定位置添加单个元素* 使用synchronized 进行同步写数据*/public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;public void add(int index, E element) &#123; insertElementAt(element, index);&#125;public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt; \" + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++;&#125;","categories":[{"name":"JAVA 集合","slug":"JAVA-集合","permalink":"http://www.uuuup.vip/categories/JAVA-集合/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"http://www.uuuup.vip/tags/ArrayList/"},{"name":"Vector","slug":"Vector","permalink":"http://www.uuuup.vip/tags/Vector/"}]}]}