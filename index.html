<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="No accumulation of thousands of miles"/>




  <meta name="keywords" content="后台,java,mongo,mysql,vue,js,css,html" />










  <link rel="alternate" href="/atom.xml" title="Brooke-Paul">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1" />



<link rel="canonical" href="http://www.uuuup.vip/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> Brooke-Paul </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Brooke-Paul</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/categories/">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Brooke-Paul</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <section id="posts" class="posts">
    
      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/01/27/jvm/Java线程安全/">Java线程安全</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-27
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java虚拟机/">Java虚拟机</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="Java操作共享数据"><a href="#Java操作共享数据" class="headerlink" title="Java操作共享数据"></a>Java操作共享数据</h2><p><code>Java</code>操作共享数据分为五类。不可变，绝对线程安全，相对线程安全，线程兼容和线程对立。   </p>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>不可变的对象一定是线程安全的，只要一个不可变对象被正确的构造出来（没有发生this引用逃逸的情况)，那么外部访问的可见状态永远不会改变。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种：被final修饰的基本类型值不能改变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种：被final修饰的对象, 对象不能改变，但是对象中的变量值可以改变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Person person = <span class="keyword">new</span> Person(<span class="string">"zhangshan"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadSafetyDemo threadSafetyDemo = <span class="keyword">new</span> ThreadSafetyDemo();</span><br><span class="line">        System.out.println(<span class="string">"不可变对象int："</span> + threadSafetyDemo.number);</span><br><span class="line">        System.out.println(<span class="string">"不可变对象string："</span> + threadSafetyDemo.message);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"不可变对象person："</span> + threadSafetyDemo.person);</span><br><span class="line">        threadSafetyDemo.person.setName(<span class="string">"lishi"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Cannot assign a value to final variable 'person'</span></span><br><span class="line"><span class="comment">//        threadSafetyDemo.person = new Person();</span></span><br><span class="line">        System.out.println(<span class="string">"不可变对象person："</span> + threadSafetyDemo.person);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里分析一下this引用逃逸，当线程RunablTest1还未初始化demo对象时，线程RunablTest2尝试获取未初始化demo对象的变量，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> ThreadSafetyDemo demo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadSafetyDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunablTest1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        demo = <span class="keyword">new</span> ThreadSafetyDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunablTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(demo.i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"发生空指针错误：普通变量j未被初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(demo.i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"发生空指针错误：final变量i未被初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunablTest2()).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunablTest1()).start();</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">发生空指针错误：普通变量j未被初始化</span><br><span class="line">发生空指针错误：<span class="keyword">final</span>变量i未被初始化</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>绝对线程安全类定义是非常严格的，要实现一个绝对线程安全的类通常需要付出很大的、甚至有时候是不切实际的代价。   </p>
<h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>相对的线程安全就是所讲的线程安全，在大部分线程安全类都属于这种类型，例如<code>Vector</code>，<code>HashTable</code>等。   </p>
<h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>线程兼容是指对象本身不是线程安全的，但可以通过同步手段保证对象在并发的同时安全的使用。   </p>
<h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境下同时持有一个线程对象。      </p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/01/20/jvm/虚拟机新能监控工具/">虚拟机新能监控工具</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-20
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java虚拟机/">Java虚拟机</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h2><h3 id="虚拟机进程状况工具jps"><a href="#虚拟机进程状况工具jps" class="headerlink" title="虚拟机进程状况工具jps"></a>虚拟机进程状况工具jps</h3><p>1). <code>jps -l</code> 输出主类的全名</p>
<p><img src="../../img/FE08C341-3CC7-48EE-84A8-E4B4CC335013.png" alt=""></p>
<p>2). <code>jps -v</code> 输出虚拟机进程启动时的JVM参数</p>
<p><img src="../../img/02F11D52-CE9A-4BB2-99EC-B1C934DC243D.jpg" alt=""></p>
<h3 id="虚拟机统计信息监控工具jstat"><a href="#虚拟机统计信息监控工具jstat" class="headerlink" title="虚拟机统计信息监控工具jstat"></a>虚拟机统计信息监控工具jstat</h3><p>1). <code>jstat -gc</code> 监视Java堆的状况，包括Eden区，survivor区，老年代，永久代的容量，已用空间以及GC时间合计的信息。</p>
<p><img src="../../img/37A04B2B-82AA-4D89-90A9-000C0440C493.jpg" alt=""></p>
<p>2). <code>jstat -gcutil</code> 监视内容基本与-gc相同，单输出内容主要是使用空间占比。</p>
<p><img src="../../img/CB867D4A-4DE1-4016-A085-912FC219C64B.jpg" alt=""></p>
<h3 id="java堆栈跟踪工具jstack"><a href="#java堆栈跟踪工具jstack" class="headerlink" title="java堆栈跟踪工具jstack"></a>java堆栈跟踪工具jstack</h3><p>1). <code>jstack -l</code> 除堆栈外，展示关于锁的附加信息。</p>
<p><img src="../../img/死锁.png" alt=""></p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/01/20/jvm/虚拟机性能监控工具/">虚拟机性能监控工具</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-20
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java虚拟机/">Java虚拟机</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h2><h3 id="虚拟机进程状况工具jps"><a href="#虚拟机进程状况工具jps" class="headerlink" title="虚拟机进程状况工具jps"></a>虚拟机进程状况工具jps</h3><p>1). <code>jps -l</code> 输出主类的全名</p>
<p><img src="../../img/FE08C341-3CC7-48EE-84A8-E4B4CC335013.png" alt=""></p>
<p>2). <code>jps -v</code> 输出虚拟机进程启动时的JVM参数</p>
<p><img src="../../img/02F11D52-CE9A-4BB2-99EC-B1C934DC243D.jpg" alt=""></p>
<h3 id="虚拟机统计信息监控工具jstat"><a href="#虚拟机统计信息监控工具jstat" class="headerlink" title="虚拟机统计信息监控工具jstat"></a>虚拟机统计信息监控工具jstat</h3><p>1). <code>jstat -gc</code> 监视Java堆的状况，包括Eden区，survivor区，老年代，永久代的容量，已用空间以及GC时间合计的信息。</p>
<p><img src="../../img/37A04B2B-82AA-4D89-90A9-000C0440C493.jpg" alt=""></p>
<p>2). <code>jstat -gcutil</code> 监视内容基本与-gc相同，单输出内容主要是使用空间占比。</p>
<p><img src="../../img/CB867D4A-4DE1-4016-A085-912FC219C64B.jpg" alt=""></p>
<h3 id="java堆栈跟踪工具jstack"><a href="#java堆栈跟踪工具jstack" class="headerlink" title="java堆栈跟踪工具jstack"></a>java堆栈跟踪工具jstack</h3><p>1). <code>jstack -l</code> 除堆栈外，展示关于锁的附加信息。</p>
<p><img src="../../img/死锁.png" alt=""></p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/01/19/jvm/JVM类加载机制/">JVM类加载机制</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-19
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java虚拟机/">Java虚拟机</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>虚拟机把描述的<code>.class</code>文件加载到内存，并对数据进行校验、准备、解析和初始化，最终能够被形成被<code>JVM</code>可以直接使用的<code>Java</code>类型的过程，这就是虚拟机的类加载机制。   </p>
<h2 id="类加载的生命周期"><a href="#类加载的生命周期" class="headerlink" title="类加载的生命周期"></a>类加载的生命周期</h2><p>类从被加载到虚拟机内存开始，到卸载出内存结束包含七个阶段。包括加载，验证，准备，解析，初始化，使用，卸载。其中验证准备以及解析三个部分被称为连接。</p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>1). 加载阶段<br>在加载阶段，虚拟机会通过类的全限定名来获取定义此类的二进制流。将字节流所代表的静态存储结构转换为方法区的运行时数据结构。在内存中生成一个代表这个类的<code>.class</code>对象，作为这个类的各种数据的访问人口。   </p>
<p>2). 验证阶段<br>验证是连接阶段的第一步，目的是确保<code>.class</code>文件的字节流信息符合虚拟机的要求。<br>验证阶段主要检验四个点：<br>   文件格式校验(校验文件编码，校验文件常量引用等)<br>   元数据验证(对字节码描述信息进行语义分析，例如类是否有父类(<code>Object</code>)，类继承时是否包含<code>final</code>修饰，以及类是否实现了接口的所有方法等等)<br>   字节码验证(主要确定语义合法，变量类型转换有效等等)<br>   符号引用验证(例如类中方法以及字段的引用是否有效，以及是否能够被访问到等等)   </p>
<p>3). 准备阶段<br>准备阶段正式为类变量分配内存并且设置类变量的初始值，这些变量使用方法区的内存进行分配。值的一提的是准备阶段内存分配的仅包括被<code>static</code>修饰的变量，而不包括实例变量。<br>默认情况下初始值为零值，但是如果被<code>final</code>修饰的变量在这个阶段会将其置为定义的值。   </p>
<p>4). 解析阶段<br>虚拟机将常量池内的符号引用替换为直接引用的过程叫做解析。<br>   类或接口的解析<br>   字段的解析<br>   类方法解析<br>   接口方法解析   </p>
<p>5). 初始化阶段<br>类加载过程的最后一步称为类初始化阶段。初始化阶段是执行类构造器<code>&lt;cinit&gt;()</code>方法的过程，并且静态语句块只能访问到定义到静态语句块之前的变量。   </p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器用于加载类，并且对于任意一个类，被类加载器加载后都可以在虚拟机中确定唯一性。<br>即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。<br>通俗一点来讲，要判断两个类是否“相同”，前提是这两个类必须被同一个类加载器加载，否则这个两个类不“相同”。<br>这里指的“相同”，包括类的<code>.class</code>对象的<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法、<code>instanceof</code>关键字等判断出来的结果。      </p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>对<code>Java</code> 虚拟机来说，只存在两种类加载器：<br>一种是启动类加载器<code>Bootstrap ClassLoader</code>，另一种是所有其他的类加载器。<br>其中启动类加载器<code>Bootstrap ClassLoader</code>加载<code>&lt;JAVA_HOME&gt;\lib</code>目录下核心库。<br>其他类加载器可以分为扩展类加载器<code>Extension ClassLoader</code>，和 应用程序类加载器<code>Application ClassLoader</code>。<br>扩展类加载器<code>Extension ClassLoader</code> 主要加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录下扩展包。<br>应用程序类加载器<code>Application ClassLoader</code> 主要加载用户路径<code>classpath</code>下的指定类库。    </p>
<p>如下图所示：  </p>
<p><img src="../../img/timg.jpeg" alt=""></p>
<p>该图即为类加载的双亲委派模型。除了顶层的类加载器之外，其余的所有类加载器必须有自己的父类加载器。<br>工作过程为：如果某个类需要被加载时默认不会自己尝试加载类，而是委托自己的父类加载器去完成。只有父类加载器无法完成该类的加载时抛出抛出异常，然后该类加载器才会尝试自己加载请求。<br>类加载器伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">判断该类是否被加载过</span><br><span class="line"><span class="keyword">if</span>（没有被加载)&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      请求父级加载器类加载</span><br><span class="line">  &#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">      如果父级无法完成类加载，异常处理</span><br><span class="line">  &#125;</span><br><span class="line">  尝试自己去进行类加载</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/01/16/jvm/垃圾收集与内存分配/">垃圾收集与内存分配</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-16
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java虚拟机/">Java虚拟机</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集（<code>Garbage Collection</code>), 俗称 <code>GC</code>。在系统中哪些内存需要回收？什么时候回收？怎样回收呢？当垃圾收集成为系统达到性能最优的阻碍时，我们就需要针对垃圾收集进行必要的监控与处理。</p>
<h2 id="对象是否存活？"><a href="#对象是否存活？" class="headerlink" title="对象是否存活？"></a>对象是否存活？</h2><p><code>Java</code>堆中存放几乎所有对象实例，垃圾收集器在回收对象时需要判断对象是否存活。哪些方法能够判断对象可以被回收呢？<br>1). 引用计数算法<br>给对象添加一个引用计数器，每当引用一次计数器 + 1， 引用失效 - 1。<br>优点：实现简单，判定效率高。<br>缺点：无法判断对象之间相互引用的问题。<br>2). 可达性分析算法<br>基本思路是通过<code>GC Roots</code>的对象作为起始点，向下开始搜索，所走过的路径成为引用链（Reference Chain）,当一个对象到 <code>GC Roots</code> 没有任何引用链相连时，表示该对象不可用，即是可以被回收的对象。<br>在 <code>Java</code> 语言中，可作为<code>GC Roots</code>的对象包括下面几种：<br>(1).虚拟机栈（栈帧中的本地变量表)中引用的对象。<br>(2).方法区中类静态属性引用的对象。<br>(3).方法区中常量引用的对象。<br>(4).本地方法栈中JNI引用的对象。   </p>
<h2 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h2><p><code>Java</code>中对对象的引用分为强引用，软引用，弱引用，虚引用四种，四种引用的强度依次递减。<br>1).强引用指的是类似<code>Object object = new Object()</code> 这类引用，只要强引用存在，引用的对象永远不会被垃圾收集器回收。<br>2).软引用描述的是有用但非必需的对象，对于软引用关联的对象，在系统将要发生内存溢出之前，系统将会把这些对象进行二次回收，如果这次回收还没有足够的内存，才会发生内存溢出异常。<br>3).弱引用也是描述非必需的对象，但是它的强度比软引用更弱一些， 被弱引用关联的对象只能生存到一下次垃圾收集之前。当垃圾回收的时候，无论内存足够，被弱引用关联的对象都会被回收。<br>4).虚引用是最弱的一种引用关系，若有若无。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>1).标记-清除算法<br>先扫描并标记需要回收的对象，然后清除。标记和清除的效率都不是很高。<br>2).复制算法<br>把内存分为两块，当使用的一块内存不足时，将所有存活的对象复制到另一块，回收当前一整块<br>内存被分为eden区survivor 区，eden:survivor = 8:1<br>3).标记整理算法<br>标记出需要清理的对象，然后其余对象移动到另一端<br>4).分代收集算法  （最优法）<br>新生代使用复制算法  （新生代对象存活时间短，采用复制算法）<br>永久代使用其他两种算法 （永久代对象存活时间较长）   </p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>Serial 是单线程收集器，并且工作时必须暂停其他线程工作。<br>ParNew 是 Serial 收集器的多线程版本，支持多条垃圾收集器并行工作。<br>Parallel Scavenge 是一个新生代收集器，使用复制算法的收集器，也是并行的多线程收集器。<br>Serial Old 是 Serial 收集器的老年代版本，也是一个单线程收集器，使用的是 标记-整理算法。<br>Parallel Old 是 Parallel Scavenge 的老年代版本，使用多线程 和 标记-整理算法。<br>CMS 是 以一种以获取最短回收停顿时间为目标的收集器，采用的是标记-清除算法。 停顿时间短，用户体验好，目前来看 CMS 收集器非常符合这类应用的需求。<br>G1收集器的优势：并行与并发， 分代收集， 空间整理 （标记整理算法，复制算法）。</p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>对象在新生代Eden区中分配，当区域内存不足时，将会发生Minor GC（称为新生代GC)。<br>对发生在老年代的GC称为Major GC， Major GC会比Minor GC的速度慢10倍以上。<br>为了计算哪些对象在新生代，那些对象在老年代，虚拟机给每个对象定义了年龄计数器， 对象在Eden区发生了 Minor GC后任然存活并且能够被 Survivor容纳的话，将会移到Survivor区域，并且设置年龄为1，<br>对象每熬过一次Minor GC，年龄 +1。当对象年龄达到晋升老年代阈值时，晋升到老年代。（默认年龄为15岁， 可以通过参数 -XX： MaxTenuringThreshold)设置。  </p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/01/15/jvm/Java内存区域/">Java内存区域</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-15
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java虚拟机/">Java虚拟机</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="Java-运行时数据区域"><a href="#Java-运行时数据区域" class="headerlink" title="Java 运行时数据区域"></a>Java 运行时数据区域</h2><p><code>Java</code>虚拟机所管理的内存包括如下图所示的几个运行时数据区域<br><img src="../../img/2018120731.png" alt=""></p>
<h3 id="Java方法区"><a href="#Java方法区" class="headerlink" title="Java方法区"></a>Java方法区</h3><p>方法区是线程共享区域，用于存储已被虚拟机加载的类信息，常量，静态变量，以及编译器编译后的代码等数据。 运行时常量池属于方法取得一部分。  </p>
<h3 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h3><p><code>Java</code> 栈分为两块，包含虚拟机栈和本地方法栈。</p>
<h4 id="1）虚拟机栈"><a href="#1）虚拟机栈" class="headerlink" title="1）虚拟机栈"></a>1）虚拟机栈</h4><p>虚拟机栈是线程私有的，它的生命周期与线程相同，每个方法运行时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出入口信息等，每个方法从调用直至执行完成的过程，就对应着一个栈帧从虚拟机中入栈到出栈的过程。<br>其中局部变量表存放了8种基本类型数据，还有对象的引用。在<code>Java</code>虚拟机中对栈规定了两种异常情况，如果请求的栈的深度大于虚拟机所允许栈的深度，将抛出<code>StackOverflowError</code>异常，如果虚拟机可以动态扩展并且在扩展时无法申请足够的内存，那么将会抛出<code>OutOfMemoryError</code>异常。   </p>
<h4 id="2）本地方法栈"><a href="#2）本地方法栈" class="headerlink" title="2）本地方法栈"></a>2）本地方法栈</h4><p>本地方法栈与虚拟机栈所发挥的作用类似，区别在于虚拟机栈为虚拟机执行<code>Java</code>方法服务， 本地方法栈为虚拟机执行<code>Native</code>方法服务。与虚拟机栈一样，本地方法栈也会抛出上面两种异常。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p><code>Java</code>堆是线程共享的。对大多数应用来说， <code>Java</code>堆是 虚拟机中被管理的最大的一块线程共享区域，在该区域存放的是对象的实例，几乎所有的对象实例都在堆中分配。<br><code>Java</code>堆是垃圾收集器管理的主要区域。现在的收集器基本都采用分代收集法，堆中可以细分为新生代和老年代，再细致一点可以分为 <code>Eden</code>区，<code>From Survivor</code>区域，<code>To Survivor</code>区域。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以作为线程的指示器。字节码解释器工作是通过改变记数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都依赖计数器来完成。</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/01/13/concurrent/CAS深入解析/">CAS深入解析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-13
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java并发/">Java并发</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p><code>CAS（Compare and swap）</code>就是比较和替换， 是一种通过硬件实现并发安全的技术。<code>CAS</code> 是 <code>JAVA</code> 并发包的实现基础，包含了三个操作数，<br>需要读写的内存位置V，进行比较的值A，以及写入的新值。当且仅当V的值等于A时，<code>CAS</code> 才会通过原子方式用新值替换旧值。<br>模拟<code>CAS</code> 原理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    旧值与传入相同，更改新值</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> oldValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value == oldValue) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁的核心算法就是采用的<code>CAS</code>, <code>CAS</code>具有原子性。乐观锁避免了悲观锁独占的现象，并且提高了并发性能。但是，乐观锁也有自己的不足：<br>1). 乐观锁只能保证一个共享变量的原子操作。<br>2). 长时间自旋操作可能导致线程开销太大。<br>3). <code>CAS</code>的核心是通过比较内存值与预期值是否一样判断内存值是否被改动过，但是这个逻辑有些不严谨。比如原来内存值为A，<br>后来被某个线程改为B，最后又被改成了A，则<code>CAS</code>认为内存值未被改变过，这种场景对依赖过程值的情景运算结果影响很大，那有什么解决办法呢？<br>解决的思路就是给每个替换时加上版本号。</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/01/10/concurrent/ThreadLocal的源码分析/">ThreadLocal的源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-10
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java并发/">Java并发</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="ThreadLocal的介绍"><a href="#ThreadLocal的介绍" class="headerlink" title="ThreadLocal的介绍"></a>ThreadLocal的介绍</h2><p><code>ThreadLocal</code>用于保存某个线程中共享变量。在同一个线程中，共享变量之间的访问时隔离的，无法跨线程访问。因此<code>ThreadLocal</code>可以用作人员信息的保存，以及展示。</p>
<h2 id="ThreadLocal提供的主要方法"><a href="#ThreadLocal提供的主要方法" class="headerlink" title="ThreadLocal提供的主要方法"></a>ThreadLocal提供的主要方法</h2><h3 id="ThreadLocal-set-用于当前线程信息保存"><a href="#ThreadLocal-set-用于当前线程信息保存" class="headerlink" title="ThreadLocal.set() 用于当前线程信息保存"></a><code>ThreadLocal.set()</code> 用于当前线程信息保存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Thread</code> 中 <code>threadLocals</code> 作为变量，用于存储 <code>ThreadLocalMap</code>。 <code>set</code> 方法获取当前线程后首先调用 <code>getMap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前线程的 <code>getMap</code> 获取的 <code>t.threadLocals</code> 为空，则调用 <code>createMap</code> 方法，<code>createMap</code> 的实现方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line">构造 一个 ThreadLocalMap 对象 并将 key， value 保存到Entry数组中。</span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前线程的 <code>getMap</code> 获取的 <code>t.threadLocals</code> 不为空，则将<code>value</code>保存到 <code>ThreadLocalMap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entry 继承自 WeakReference， 当对象不再使用时会被回收，避免内存泄漏。</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">	    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">	    Object value;</span><br><span class="line">	</span><br><span class="line">	    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">	        <span class="keyword">super</span>(k);</span><br><span class="line">	        value = v;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocal-get-用于当前线程信息获取"><a href="#ThreadLocal-get-用于当前线程信息获取" class="headerlink" title="ThreadLocal.get() 用于当前线程信息获取"></a><code>ThreadLocal.get()</code> 用于当前线程信息获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread(); 获取当前线程，</span><br><span class="line">    ThreadLocalMap map = getMap(t); 获取当前线程本地变量</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 本地线程变量不为空，从<code>getEntry</code> 中获取 <code>Entry</code> 对象   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>否则调用 <code>setInitialValue</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给一个空的value值， 之后的逻辑与 `ThreadLocal` 的 `set` 方法一致，获取当前线程本地变量，如果不为空重新设值，为空创建新的 `ThreadLocalMap`对象。      </span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     T value = initialValue();</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">     <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">         map.set(<span class="keyword">this</span>, value);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         createMap(t, value);</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocal-remove-用于当前线程移除本地变量"><a href="#ThreadLocal-remove-用于当前线程移除本地变量" class="headerlink" title="ThreadLocal.remove() 用于当前线程移除本地变量"></a><code>ThreadLocal.remove()</code> 用于当前线程移除本地变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">      <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">          m.remove(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/01/07/concurrent/Synchronized与ReadWriteLock的区别/">Synchronized与ReadWriteLock的区别</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-07
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java并发/">Java并发</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p><code>Synchronized</code>关键字是最基本的互斥同步，经过编译之后，会在同步块的前后形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令，在和执行<code>monitorenter</code><br>指令时，首先会尝试获取对象的锁，把锁的计数器加一。相应的，在执行<code>monitorexit</code>指令时会将计数器的值减一，当计数器的值为零时锁会被释放。如果获取对象锁失败，那么当前线程就会阻塞等待，直到对象锁被另一个线程释放为止。</p>
<h2 id="Synchronized与ReadWriteLock相同点"><a href="#Synchronized与ReadWriteLock相同点" class="headerlink" title="Synchronized与ReadWriteLock相同点"></a>Synchronized与ReadWriteLock相同点</h2><p>1.在多线程并发编程中都能实现同步，当某个方法被<code>Synchronized</code>修饰时，其它的线程无法访问当前方法，只有阻塞等待此方法同步完成后获取锁。<br>2.<code>ReadWriteLock</code>为读写锁，适用情况为读多写少的场景，和<code>Synchronized</code>一样可以锁住某个方法，但是得手动释放锁。<br>3.<code>Synchronized</code> 和 <code>ReadWriteLock</code> 都是可重入锁，即一个线程在获取某个锁后，还可以继续获取同一个锁。</p>
<h2 id="Synchronized与ReadWriteLock区别"><a href="#Synchronized与ReadWriteLock区别" class="headerlink" title="Synchronized与ReadWriteLock区别"></a>Synchronized与ReadWriteLock区别</h2><p>在内置锁<code>Synchronized</code>中使用简洁，不需要每次使用后手动释放锁，而<code>ReadWriteLock</code>必须每次使用后手动释放锁。<br>在内置锁<code>Synchronized</code>中不能手动中断锁操作，而<code>ReadWriteLock</code>可以手动取消锁。<br><code>ReadWriteLock</code>是一种性能优化措施，执行读锁时效率比<code>Synchronized</code> 更高。</p>
<p>总结：<br>显示锁的设置上要灵活些，比如定时，轮询，以及中断操作等，但是使用难度要大些，并且容易忽略锁的释放。<br>当<code>Synchronized</code>无法满足多线程同步时才使用<code>ReadWriteLock</code>，否则尽量使用<code>Synchronized</code>。<br><code>ReadWriteLock</code>使用场景，当允许多个读线程并发的访问被保护的对象时可以使用读写锁，提高程序可伸缩性。</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/01/06/concurrent/显示锁的使用/">锁的使用</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-06
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java并发/">Java并发</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="显示锁介绍"><a href="#显示锁介绍" class="headerlink" title="显示锁介绍"></a>显示锁介绍</h2><p>java5.0之前，线程对共享对象的访问可以使用<code>synchronized</code> 和 <code>volatile</code>。java5.0之后新增了一种新机制， <code>ReentrantLock</code>。它并不是一种替代内置锁的方法，而是作为一种当内置锁机制不适用时的高级功能使用。<br><code>Lock</code> 定义了一种加锁操作， 与内置锁不同的是提供了一种可轮询的，可定时的，以及可中断的获取锁的操作。加锁和释放锁的操作都是显示执行的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>; <span class="comment">//加锁操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;  <span class="comment">//该锁与lock相似，但可以被中断</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;  <span class="comment">//尝试获取锁操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">//在指定的时间内尝试获取所操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;  <span class="comment">//释放锁操作</span></span><br><span class="line"></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>; <span class="comment">//创建Condition对象，精细的控制多线程的休眠与唤醒</span></span><br></pre></td></tr></table></figure></p>
<h2 id="显示锁的三种使用方式"><a href="#显示锁的三种使用方式" class="headerlink" title="显示锁的三种使用方式"></a>显示锁的三种使用方式</h2><h3 id="第一种-轮询锁"><a href="#第一种-轮询锁" class="headerlink" title="第一种 轮询锁"></a>第一种 轮询锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">轮询顺序尝试获取两个锁，如果顺利获取并且转账金额小于当前用户的实际金额，加锁转账，释放锁。</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fromAcct.lock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (toAcct.lock.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (fromAcct.getBalance().compareTo(amount) &lt; <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                fromAcct.debit(amount);</span><br><span class="line">                                toAcct.credit(amount);</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            toAcct.lock.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    fromAcct.lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (System.nanoTime() &lt; stopTime)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            NANOSECONDS.sleep(fixedDelay + rnd.nextLong() % randMod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种-定时锁"><a href="#第二种-定时锁" class="headerlink" title="第二种 定时锁"></a>第二种 定时锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">尝试获取锁，设置当前锁的失效时间，如果在指定时间内未获取到锁，返回失败信息，获取锁后更改信息，最后释放锁</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">timeLockTest</span><span class="params">(String message,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanosToLock = unit.toNanos(timeout)</span><br><span class="line">                - estimatedNanosToSend(message);</span><br><span class="line">        <span class="keyword">if</span> (!lock.tryLock(nanosToLock, NANOSECONDS))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> doSomeThing(message);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三种-可中断锁"><a href="#第三种-可中断锁" class="headerlink" title="第三种 可中断锁"></a>第三种 可中断锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">设置获取锁的同时保持对中断的响应，然后取消获取锁操作</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendSharedLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> cancelSendSharedLine(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="锁的公平性"><a href="#锁的公平性" class="headerlink" title="锁的公平性"></a>锁的公平性</h2><p>创建锁对象时默认创建非公平锁，非公平锁允许插队，公平锁必须按照顺序来获取锁。在获取锁的激烈竞争下，非公平锁的性能高于公平锁。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在<code>Synchronized</code> 中和 <code>ReentrantLock</code>中做出选择</p>
<p><code>ReentrantLock</code> 的性能优于内置锁， 可以作为一种高级工具使用，功能包括可定时的，可轮询的，可中断的所获取操作。但是对于内置锁来说，它任然具有很大的优势，不需要自己手动去释放锁，并且使用简介紧凑。</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/01/02/concurrent/线程的优化/">Java线程的优化</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-02
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java并发/">Java并发</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程?"></a>为什么使用线程?</h2><p>因为串行执行任务时，所有的任务节点必须按照顺序执行，如果处理任务时执行时间过长，可能会导致程序无响应。在这种情况下，线程就派上用处了。线程的主要目的是提高程序的运行性能。尽管使用多个线程可以提升整体性能，但与单个线程相比，多个线程使用总会引入额外的开销。如果多线程设计有误，实现某个功能时性能甚至比单线程的性能还差。所以在使用线程时评估好任务执行耗时，充分利用资源进行优化。</p>
<h2 id="线程引入的开销有哪些"><a href="#线程引入的开销有哪些" class="headerlink" title="线程引入的开销有哪些?"></a>线程引入的开销有哪些?</h2><p>在考虑使用多线程时，并行带来的性能提升必须要大于并发导致的性能开销，否则不要使用多线程。<br>具体的线程开销有三种<br>1.上下文切换， 是指<code>CPU</code>从一个线程或进程切换到另一个线程或进程。 当线程执行时发生的阻塞越多，与<code>CPU</code>密集型的程序就会发生越多的上下文切换，从而增加线程的开销。<br>2.内存同步，在使用<code>volatile</code>提供内存可见性时会使用一些特殊指令，即内存栅栏。内存栅栏可以刷新缓存，但是同样间接性的带来了性能上的影响，因为抑制了编译器的优化操作。在内存栅栏中，大多数操作是不能被重排序的。<br>3.线程阻塞，线程的竞争会增加开销。在锁上发生竞争时，竞争失败的线程会阻塞。当线程无法获取某个锁或者线程等待或者产生<code>I/O</code>阻塞时，线程被挂起，这个过程包含两次额外的上下文切换。</p>
<h2 id="怎样降低锁的竞争"><a href="#怎样降低锁的竞争" class="headerlink" title="怎样降低锁的竞争"></a>怎样降低锁的竞争</h2><p>串行操作会降低可伸缩性，并且上下文切换时也会降低性能。在锁上发生竞争会导致这些问题，因此减小锁的竞争能够提高性能和可伸缩性。<br>有三种方式可以降低锁的竞争程度：<br>1.减小锁的持有时间，尽可能的缩短锁的持有时间，例如将与锁无关的代码移出代码块，尤其是开销较大的，以及可能被阻塞的操作。<br>2.减小锁的粒度，降低单位时间内请求锁的次数，从而降低竞争的可能性。<br>3.锁分段，将锁分解技术进一步扩展对一组独立对象上的锁进行分解。<br>4.避免热点区。<br>5.放弃使用独占锁。例如使用并发容器，读写锁，不可变对象以及原子变量。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>程序的可伸缩性取决于所有代码中必须被串行执行的代码比例，我们可以通过以下方式来提高可伸缩性：<br>减少锁的持有时间，降低锁的粒度，采用非独占式的锁或非阻塞锁来代替独占锁。</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/12/23/concurrent/线程池大小设置/">合理设置Java线程池大小</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-23
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java并发/">Java并发</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="设置Java线程池大小"><a href="#设置Java线程池大小" class="headerlink" title="设置Java线程池大小"></a>设置Java线程池大小</h2><p>线程池大小设置取决于所部署的系统中包含的<code>CPU</code>， 内存。 必须分析计算环境，资源预算和任务的特性。</p>
<h3 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h3><p>尽量使用较小的线程池，一般<code>CPU</code>核心数+1。因为<code>CPU</code>密集型任务CPU的使用率很高，若开过多的线程，只能增加线程上下文的切换次数，带来额外的开销。<br>任务特性分为<code>CPU</code>密集型， <code>IO</code>密集型，混合密集型。对于<code>CPU</code>密集型， 在拥有<code>N</code>个<code>CPU</code>的处理器系统中，线程设置为 n + 1。   </p>
<h3 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h3><p>可以使用较大的线程池，一般<code>CPU</code>核心数 <em> 2， <code>IO</code>密集型<code>CPU</code>使用率不高，可以让<code>CPU</code>等待<code>IO</code>的时候处理别的任务，充分利用<code>CPU</code>时间。<br>对于<code>IO</code>密集型，线程设置为 最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）</em> CPU数目， 比如线程等待时间为 1s,<br>而线程<code>CPU</code>时间为0.5s，假设当前<code>CPU</code>核心数为4核，则当前线程池大小为12。</p>
<p>在实际项目中可以通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cpuNum = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure></p>
<p>获取<code>CPU</code> cpuNum数目。<br>结论：线程等待时间所占比例越高，需要越多线程。线程<code>CPU</code>时间所占比例越高，需要越少线程。</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/12/23/concurrent/线程池的初始化/">Java线程池的初始化</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-23
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java并发/">Java并发</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="线程池初始化"><a href="#线程池初始化" class="headerlink" title="线程池初始化"></a>线程池初始化</h2><p>在之前文章中简单介绍了线程池的四种使用方式，在本节中将具体讲解它们的底层实现。</p>
<p>首先四种工具方法的实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">newFixedThreadPool是一个固定长度的线程池</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">newSingleThreadExecutor是一个单线程的线程池</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">newCachedThreadPool是一个可缓存的线程池</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">newScheduledThreadPool是一个固定长度的线程池</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中每个工具类方法都会调用公用的构造器 <code>ThreadPoolExecutor</code>，实现方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>核心参数的含义：<br>corePoolSize： 核心池的大小。默认情况下县城创建后线程池的大小为0，当任务来时创建线程去执行任务，当线程池的线程数量达到核心池数量时，就会把任务放到队列中等待线程执行。<br>maximumPoolSize：线程池最大线程数，这表示线程池所能创建的最大线程数。<br>keepAliveTime： 线程未执行任务时经过多长时间被回收。默认情况下只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用。但是但是如果调用了allowCoreThreadTimeOut(boolean)方法，<br>在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0。<br>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;               <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure></p>
<p>workQueue：一个阻塞队列，用来存储等待执行的任务，一般来说，这里的阻塞队列有以下几种选择：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;  基于数组的先进先出队列，此队列创建时必须指定大小。</span><br><span class="line">LinkedBlockingQueue; 基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE。</span><br><span class="line">SynchronousQueue;    这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</span><br></pre></td></tr></table></figure></p>
<p>threadFactory：线程工厂类，有默认实现，如果有自定义的需要则需要自己实现ThreadFactory接口并作为参数传入。</p>
<p>handler：表示当拒绝处理任务时的策略，有以下四种取值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。（默认使用方式） </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure></p>
<h2 id="二种线程方法执行"><a href="#二种线程方法执行" class="headerlink" title="二种线程方法执行"></a>二种线程方法执行</h2><p>1.带返回值的线程提交<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>); <span class="comment">//返回一个FutureTask对象</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.不带返回值的线程提交，交由线程池去执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="线程方法关闭"><a href="#线程方法关闭" class="headerlink" title="线程方法关闭"></a>线程方法关闭</h2><p>shutdown() 与 shutdownNow()<br><code>shutdown</code> 不会立即终止线程池，在不接收新的任务同时等待缓存队列中的任务执行完成后终止。<br><code>shutdownNow</code> 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</p>
<p>举个例子：新建一个线程池测试带返回值的任务执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nThreads = <span class="number">5</span>;</span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                Future future = executorService.submit(<span class="keyword">new</span> TaskResult());</span><br><span class="line">                futures.add(future);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; futures.size(); j++) &#123;</span><br><span class="line">                System.out.println(futures.get(j).get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskResult</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">": 执行完毕"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br>pool-1-thread-1: 执行完毕<br>pool-1-thread-2: 执行完毕<br>pool-1-thread-3: 执行完毕<br>pool-1-thread-4: 执行完毕<br>pool-1-thread-5: 执行完毕<br>pool-1-thread-3: 执行完毕<br>pool-1-thread-3: 执行完毕<br>pool-1-thread-2: 执行完毕<br>pool-1-thread-3: 执行完毕<br>pool-1-thread-3: 执行完毕</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/12/20/更改github作者信息/">github更改作者的提交信息</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-20
        </span>
        
          <span class="post-category">
            
              <a href="/categories/git/">git</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2><p><code>github</code>拉取代码分支后提交后贡献值不增加</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>执行第一步：<br><code>git config --global user.email &quot;youremail@googl.com&quot;</code><br><code>git config --global user.name &quot;your name&quot;</code></p>
<p>执行第二步：<br><code>git clone --bare https://github.com/user/repo.git</code><br><code>cd repo.git</code></p>
<p>执行第三步：</p>
<figure class="highlight plain"><figcaption><span>filter-branch --env-filter '</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OLD_EMAIL=&quot;your-old-email@example.com&quot; // 你的旧的email账号</span><br><span class="line">CORRECT_NAME=&quot;Your Correct Name&quot;   // 你的新的用户名</span><br><span class="line">CORRECT_EMAIL=&quot;your-correct-email@example.com&quot; // 你的新的email账号</span><br><span class="line"></span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">&apos; --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure>
<p>执行第四步：<br><code>git push --force --tags origin &#39;refs/heads/*&#39;</code></p>
<p>ok，至此作者信息修改完毕</p>
<p>此时本地仓库提交代码会失败，首先执行 更新：<code>git pull origin master --allow-unrelated-histories</code></p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/12/15/concurrent/Java线程池的四种使用方式/">Java线程池的四种使用方式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-15
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java并发/">Java并发</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p><code>Executor</code> 中常用的四种静态方法：<br>        <code>1.newSingleThreadExecutor</code>是一个单线程的Executor，使用唯一的线程来执行任务。<br>        <code>2.newFixedThreadPool</code>是一个固定长度的线程池，每当提交任务时就会创建线程，直到线程池最大数量，线程池的规模不再变化。<br>        <code>3.newCachedThreadPool</code>是一个可缓存的线程池，线程池的规模不存在任何限制。 如果当前线程池的资源有空闲，那么将回收空闲资源。如果资源增加时需要线程，则向线程池添加线程。<br>        <code>4.newScheduledThreadPool</code>是一个固定长度的线程池，并且以延迟的方式来执行任务。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorTask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.newSingleThreadExecutor是一个单线程的Executor，使用唯一的线程来执行任务。</span></span><br><span class="line">        ExecutorService executorService1 = Executors.newSingleThreadExecutor();</span><br><span class="line">        executorService1.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"newSingleThreadExecutor is done"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService1.shutdown();</span><br><span class="line">        <span class="comment">// 2.newFixedThreadPool是一个固定长度的线程池，每当提交任务时就会创建线程，直到线程池最大数量，线程池的规模不再变化。</span></span><br><span class="line">        ExecutorService executorService2 = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        executorService2.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"newFixedThreadPool is done"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService2.shutdown();</span><br><span class="line">        <span class="comment">// 3.newCachedThreadPool是一个可缓存的线程池，线程池的规模不存在任何限制。 如果当前线程池的资源有空闲，那么将回收空闲资源。如果资源增加时需要线程，则向线程池添加线程。</span></span><br><span class="line">        ExecutorService executorService3 = Executors.newCachedThreadPool();</span><br><span class="line">        executorService3.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"newCachedThreadPool is done"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService3.shutdown();</span><br><span class="line">        <span class="comment">// 4.newScheduledThreadPool是一个固定长度的线程池，并且以延迟的方式来执行任务。</span></span><br><span class="line">        ExecutorService executorService4 = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        executorService4.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"newScheduledThreadPool is done"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService4.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/12/11/concurrent/FutureTask使用/">FutureTask 配合 ConcurrentHashMap 使用</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-11
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java并发/">Java并发</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="FutureTask介绍"><a href="#FutureTask介绍" class="headerlink" title="FutureTask介绍"></a>FutureTask介绍</h2><p><code>FutureTask</code>可用于异步获取执行结果或取消执行任务的场景。通过传入<code>Runnable</code>或者<code>Callable</code>的任务给<code>FutureTask</code>，直接调用其<code>run</code>方法或者放入线程池执行，之后可以在外部通过<code>FutureTask</code>的<code>get</code>方法异步获取执行结果。   </p>
<h2 id="ConcurrentHashMap-见文章-ConcurrentHashMap的源码分析"><a href="#ConcurrentHashMap-见文章-ConcurrentHashMap的源码分析" class="headerlink" title="ConcurrentHashMap 见文章 ConcurrentHashMap的源码分析"></a>ConcurrentHashMap 见文章 <a href="https://www.uuuup.vip/2018/09/12/ConcurrentHashMap/">ConcurrentHashMap的源码分析</a></h2><h2 id="本章节利用-ConcurrentHashMap-与-FutureTask-构建在多线程环境中高效的获取数据结果缓存"><a href="#本章节利用-ConcurrentHashMap-与-FutureTask-构建在多线程环境中高效的获取数据结果缓存" class="headerlink" title="本章节利用 ConcurrentHashMap 与 FutureTask 构建在多线程环境中高效的获取数据结果缓存"></a>本章节利用 ConcurrentHashMap 与 FutureTask 构建在多线程环境中高效的获取数据结果缓存</h2><p>例如： 在多线程环境中对比 通过(<code>ConcurrentHashMap</code> 与 <code>FutureTask</code>) 和 通过 <code>Map</code> 获取人员积分 （此处积分用随机数代替）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidCacheTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Future&lt;Integer&gt;&gt; concurrentHashMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Future&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ValidCacheTest validCacheTest = <span class="keyword">new</span> ValidCacheTest();</span><br><span class="line">        String personID = <span class="string">"123456"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Object o1 = validCacheTest.compute(personID);</span><br><span class="line">                        Object o2 = validCacheTest.computeMap(personID);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"使用concurrentHashMap人员积分为："</span> + (Integer) o1);</span><br><span class="line">                        System.out.println(<span class="string">"使用map人员积分为："</span> + (Integer) o2);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">compute</span><span class="params">(String personID)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Future future = concurrentHashMap.get(personID);</span><br><span class="line">        <span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Callable callable = <span class="keyword">new</span> Callable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 从数据库通过人员ID获取积分，这里暂用随机数</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            FutureTask futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line">            <span class="comment">//putIfAbsent在放入数据时，如果存在重复的key，那么putIfAbsent不会放入值，线程安全</span></span><br><span class="line">            future = concurrentHashMap.putIfAbsent(personID, futureTask);</span><br><span class="line">            <span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;</span><br><span class="line">                future = futureTask;</span><br><span class="line">                futureTask.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> future.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">computeMap</span><span class="params">(String personID)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object object = map.get(personID);</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object o = <span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//putIfAbsent在放入数据时，如果存在重复的key，那么putIfAbsent不会放入值，线程不安全</span></span><br><span class="line">            object = map.putIfAbsent(personID, o);</span><br><span class="line">            <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">                object = o;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">测试结果：（多次执行任务发现使用map时获取的值在多线程中不一致，而concurrentHashMap中获取的值不变）</span><br><span class="line">        使用map人员积分为：<span class="number">648</span></span><br><span class="line">        使用concurrentHashMap人员积分为：<span class="number">622</span></span><br><span class="line">        使用map人员积分为：<span class="number">650</span></span><br><span class="line">        使用concurrentHashMap人员积分为：<span class="number">622</span></span><br><span class="line">        使用map人员积分为：<span class="number">650</span></span><br><span class="line">        使用concurrentHashMap人员积分为：<span class="number">622</span></span><br><span class="line">        使用map人员积分为：<span class="number">650</span></span><br><span class="line">        使用concurrentHashMap人员积分为：<span class="number">622</span></span><br><span class="line">        使用map人员积分为：<span class="number">650</span></span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> <code>FutureTask</code>在高并发环境下确保任务只执行一次，配合<code>concurrentHashMap</code>使用，支持高并发的同时确保线程安全性。</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/12/10/concurrent/CyclicBarrier/">Java同步工具之CyclicBarrier</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-10
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java并发/">Java并发</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="Java并发之同步工具-CyclicBarrier"><a href="#Java并发之同步工具-CyclicBarrier" class="headerlink" title="Java并发之同步工具 CyclicBarrier"></a>Java并发之同步工具 CyclicBarrier</h2><h3 id="CyclicBarrier循环屏障"><a href="#CyclicBarrier循环屏障" class="headerlink" title="CyclicBarrier循环屏障"></a>CyclicBarrier循环屏障</h3><p><code>CyclicBarrier</code>用于让一组线程运行并互相等待，直到共同到达一个公共屏障点 (<code>common barrier point</code>，又被称为同步点)，被屏障拦截的所有线程就会继续执行。</p>
<p><code>CyclicBarrier</code>与<code>CountDownLatch</code>的功能非常类似。但一个<code>CyclicBarrier</code>实例在释放等待线程后可以继续使用。让下一批线程在屏障点等待。但<code>CountDownLatch</code>实例只能被使用一次。所以<code>CyclicBarrier</code>被称为循环 的 <code>barrier</code>。</p>
<h3 id="CyclicBarrier类的用法"><a href="#CyclicBarrier类的用法" class="headerlink" title="CyclicBarrier类的用法"></a>CyclicBarrier类的用法</h3><p>构造方法</p>
<p><code>CyclicBarrier(int parties)</code> 创建<code>CyclicBarrier</code>对象，<code>parties</code> 表示屏障拦截的线程数量。</p>
<p><code>CyclicBarrier(int parties, Runnable barrierAction)</code> 创建 <code>CyclicBarrier</code>对象，该构造方法提供了一个<code>Runnable</code>参数，在一组线程中的最后一个线程到达之后，执行<code>Runnable</code>中的程序，再之后释放正在等待的线程。<code>Runnable</code>在屏障点上只运行一次。</p>
<p>方法</p>
<p><code>int await()</code> 通知<code>CyclicBarrier</code>实例，当前线程已经到达屏障点，然后当前线程将被阻塞。</p>
<p><code>int await(long timeout, TimeUnit unit)</code>指定当前线程被阻塞的时间。</p>
<p><code>int getNumberWaiting()</code>返回当前在屏障处等待的线程数。</p>
<p><code>int getParties()</code>返回<code>CyclicBarrier</code>的需要拦截的线程数。</p>
<p><code>boolean isBroken()</code> 查询此屏障是否处于损坏状态。</p>
<p><code>void reset()</code> 将屏障重置为其初始状态。</p>
<p>例如：所有的线程都到达共同屏障点后执行数据，可以用于分类数据求总和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parties = <span class="number">5</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(parties, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(currentThread().getName() + <span class="string">"所有线程执行完毕，结束"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parties; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(currentThread().getName() + <span class="string">"准备执行"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        System.out.println(currentThread().getName() + <span class="string">" 开始执行，等待别的线程执行完毕"</span>);</span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        System.out.println(currentThread().getName() + <span class="string">" 执行完毕，等待别的线程执行完毕"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">运行结果：</span><br><span class="line">Thread-<span class="number">0</span>准备执行</span><br><span class="line">Thread-<span class="number">4</span>准备执行</span><br><span class="line">Thread-<span class="number">1</span>准备执行</span><br><span class="line">Thread-<span class="number">3</span>准备执行</span><br><span class="line">Thread-<span class="number">2</span>准备执行</span><br><span class="line">Thread-<span class="number">4</span> 开始执行，等待别的线程执行完毕</span><br><span class="line">Thread-<span class="number">3</span> 开始执行，等待别的线程执行完毕</span><br><span class="line">Thread-<span class="number">0</span> 开始执行，等待别的线程执行完毕</span><br><span class="line">Thread-<span class="number">2</span> 开始执行，等待别的线程执行完毕</span><br><span class="line">Thread-<span class="number">1</span> 开始执行，等待别的线程执行完毕</span><br><span class="line">Thread-<span class="number">3</span>所有线程执行完毕，结束</span><br><span class="line">Thread-<span class="number">3</span> 执行完毕，等待别的线程执行完毕</span><br><span class="line">Thread-<span class="number">0</span> 执行完毕，等待别的线程执行完毕</span><br><span class="line">Thread-<span class="number">4</span> 执行完毕，等待别的线程执行完毕</span><br><span class="line">Thread-<span class="number">1</span> 执行完毕，等待别的线程执行完毕</span><br><span class="line">Thread-<span class="number">2</span> 执行完毕，等待别的线程执行完毕</span><br></pre></td></tr></table></figure></p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/12/07/concurrent/CountDownLatch/">Java同步工具之CountDownLatch</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-07
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java并发/">Java并发</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="Java并发之同步工具-CountDownLatch"><a href="#Java并发之同步工具-CountDownLatch" class="headerlink" title="Java并发之同步工具 CountDownLatch"></a>Java并发之同步工具 CountDownLatch</h2><h3 id="CountDownLatch-概念"><a href="#CountDownLatch-概念" class="headerlink" title="CountDownLatch 概念"></a>CountDownLatch 概念</h3><p><code>CountDownLatch</code> 是一种灵活的闭锁实现，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器初始化为一个正整数，表示需要等待的事件数量。<br><code>countDown</code> 方法递减计数器，表示事件发生。而<code>await</code>方法等待计数器达到零，这表示所有需要等待的事件都已经发生，可以执行自定义的操作。如果计数器的值非零，那么<code>await</code>会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。</p>
<h3 id="CountDownLatch类的用法"><a href="#CountDownLatch类的用法" class="headerlink" title="CountDownLatch类的用法"></a><code>CountDownLatch</code>类的用法</h3><p>构造方法：<br><code>CountDownLatch(int count)</code> 构造方法参数指定了计数的次数。</p>
<p>方法：<br><code>void await()</code>  使当前线程在锁存器倒计数至0之前一直等待，除非线程被中断。<br><code>boolean await(long timeout, TimeUnit unit)</code>  使当前线程在锁存器倒计数至0之前一直等待，除非线程被中断或超出了指定的等待时间。<br><code>void countDown()</code>  计数减1。当计数为0，则释放所有等待的线程。<br><code>long getCount()</code>  返回当前计数。<br><code>String toString()</code>  返回标识此锁存器及其状态的字符串。 </p>
<p>例如：使用了两个闭锁，分别表示起始门和结束门，当起始门的值为零时触发结束门的<code>countDown</code>，能使主线程高效的等待所有工作执行完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nThreads = <span class="number">5</span>;</span><br><span class="line">        CountDownLatch countDownLatchStart = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch countDownLatchEnd = <span class="keyword">new</span> CountDownLatch(nThreads);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (countDownLatchEnd) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(currentThread().getName() + <span class="string">" countDownLatchStart start..."</span>);</span><br><span class="line">                            <span class="keyword">super</span>.run();</span><br><span class="line">                            countDownLatchStart.await();</span><br><span class="line">                            System.out.println(currentThread().getName() + <span class="string">" countDownLatchStart end..."</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            countDownLatchEnd.countDown();</span><br><span class="line">                            System.out.println(<span class="string">"current countDown count is..."</span> + countDownLatchEnd.getCount());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        countDownLatchStart.countDown();</span><br><span class="line"></span><br><span class="line">        countDownLatchEnd.await();</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"countDownLatchEnd end...cost("</span> + (endTime - startTime) + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">Thread-<span class="number">0</span> countDownLatchStart start...</span><br><span class="line">Thread-<span class="number">0</span> countDownLatchStart end...</span><br><span class="line">current countDown count is...<span class="number">4</span></span><br><span class="line">Thread-<span class="number">4</span> countDownLatchStart start...</span><br><span class="line">Thread-<span class="number">4</span> countDownLatchStart end...</span><br><span class="line">current countDown count is...<span class="number">3</span></span><br><span class="line">Thread-<span class="number">3</span> countDownLatchStart start...</span><br><span class="line">Thread-<span class="number">3</span> countDownLatchStart end...</span><br><span class="line">current countDown count is...<span class="number">2</span></span><br><span class="line">Thread-<span class="number">2</span> countDownLatchStart start...</span><br><span class="line">Thread-<span class="number">2</span> countDownLatchStart end...</span><br><span class="line">current countDown count is...<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span> countDownLatchStart start...</span><br><span class="line">Thread-<span class="number">1</span> countDownLatchStart end...</span><br><span class="line">current countDown count is...<span class="number">0</span></span><br><span class="line">countDownLatchEnd end...cost(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="CountDownLatch的不足"><a href="#CountDownLatch的不足" class="headerlink" title="CountDownLatch的不足"></a>CountDownLatch的不足</h3><p><code>CountDownLatch</code>是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当<code>CountDownLatch</code>使用完毕后，它不能再次被使用。</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/12/07/concurrent/Semaphore/">Java同步工具之Semaphore</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-07
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java并发/">Java并发</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="Java并发之同步工具-Semaphore"><a href="#Java并发之同步工具-Semaphore" class="headerlink" title="Java并发之同步工具 Semaphore"></a>Java并发之同步工具 Semaphore</h2><h3 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h3><p><code>Semaphore</code> 用于控制线程并发数，<code>Semaphore</code> 可以控制同时访问资源的线程个数，实现一个文件允许访问的并发数。<br><code>Semaphore</code>维护了一个许可集，当调用<code>acquire()</code> 方法获取到许可时即可进入，无法获取许可的线程阻塞到有许可（或者直到连接中断或者连接超时）。<br>而 <code>release()</code> 表示释放一个许可。可以把<code>Semaphore</code>看成是一种共享锁。<code>Semaphore</code>允许同一时间多个线程同时访问临界区。</p>
<h3 id="Semaphore类的用法"><a href="#Semaphore类的用法" class="headerlink" title="Semaphore类的用法"></a>Semaphore类的用法</h3><p>常用方法：<br><code>public void acquire()</code>  获取许可。</p>
<p><code>public boolean tryAcquire()</code>  尝试获取许可。</p>
<p><code>public boolean tryAcquire(long timeout, TimeUnit unit)</code> 在指定的时间内尝试地获取1个许可。</p>
<p><code>public void release()</code>  释放许可。该方法一般调用于finally块中。<br><code>int availablePermits()</code> 返回此信号量中当前可用的许可数。</p>
<p>例如： 在多线程中展示信号量的可用许可，为了准确测试当前许可数量，需要同步锁住<code>semaphore</code> 对象进行测试。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> permits = <span class="number">4</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(permits);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; permits; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (semaphore) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"当前可用许可 "</span> + (semaphore.availablePermits()));</span><br><span class="line">                            semaphore.acquire();</span><br><span class="line">                            <span class="keyword">super</span>.run();</span><br><span class="line">                            System.out.println(currentThread().getName() + <span class="string">" 获取一个许可"</span>);</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"当前可用许可 "</span> + (semaphore.availablePermits()));</span><br><span class="line">                            System.out.println(currentThread().getName() + <span class="string">" 释放一个许可"</span>);</span><br><span class="line">                            semaphore.release();</span><br><span class="line">                            System.out.println(<span class="string">"当前可用许可 "</span> + (semaphore.availablePermits()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">当前可用许可 <span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span> 获取一个许可</span><br><span class="line">当前可用许可 <span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span> 释放一个许可</span><br><span class="line">当前可用许可 <span class="number">4</span></span><br><span class="line">Thread-<span class="number">3</span> 获取一个许可</span><br><span class="line">当前可用许可 <span class="number">3</span></span><br><span class="line">Thread-<span class="number">3</span> 释放一个许可</span><br><span class="line">当前可用许可 <span class="number">4</span></span><br><span class="line">Thread-<span class="number">2</span> 获取一个许可</span><br><span class="line">当前可用许可 <span class="number">3</span></span><br><span class="line">Thread-<span class="number">2</span> 释放一个许可</span><br><span class="line">当前可用许可 <span class="number">4</span></span><br><span class="line">Thread-<span class="number">1</span> 获取一个许可</span><br><span class="line">当前可用许可 <span class="number">3</span></span><br><span class="line">Thread-<span class="number">1</span> 释放一个许可</span><br></pre></td></tr></table></figure></p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/11/29/concurrent/Volatile/">Volatile关键字解析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-11-29
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 在介绍<code>Volatile</code>之前，先简单了解一下<code>java</code>内存模型。在<code>java</code>内存模型中规定，简称为<code>JMM</code>。</p>
<h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><h3 id="主内存"><a href="#主内存" class="headerlink" title="主内存"></a>主内存</h3><p>存放数据共享的区域，数据可以在线程中共享，包括实例变量，静态变量等。线程在工作时，需要将主存中的数据拷贝到工作内存，线程之间的数据不可以共享，并且不能直接操作主内存或者其他线程工作内存中的数据。<br>这里所提到的主内存可以简单认为是堆内存，而工作内存可以简单认为是栈内存。</p>
<h3 id="工作内存"><a href="#工作内存" class="headerlink" title="工作内存"></a>工作内存</h3><p>每个线程有自己的工作内存，各个线程之间不支持数据资源共享，线程使用的变量是从主内存的副本拷贝，线程所有的数据操作必须在工作内存中，无法直接获取主内存的数据，线程之间的变量值传递必须通过主内存来完成。</p>
<h2 id="Volatile-原理"><a href="#Volatile-原理" class="headerlink" title="Volatile 原理"></a>Volatile 原理</h2><p>   <code>Java</code>语言提供了一种稍弱的同步机制，即<code>volatile</code>变量，确保变量的更新操作通知到其他线程。当线程变量被<code>volatile</code>修饰后，编译器会自动识别该变量属于线程共享，因此在读取<code>volatile</code>修饰的变量时总是读取最新的值。</p>
<p>   在访问<code>volatile</code>变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此<code>volatile</code>变量是一种比<code>sychronized</code>关键字更轻量级的同步机制。</p>
<h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>   变量在被<code>volatile</code>修饰后更改变量的值会立即被写回主存，同时会使其他线程工作内存的旧值失效，新值对于其他线程是可见的，因为<code>volatile</code>修饰的变量在每个线程中使用前都会去主内存中获取最新的值。<br>   虽然<code>volatile</code>修饰的值每次都会被线程获取到，但是并不能保证线程并发的安全性。因为忽略了原子性，<code>volatile</code>在执行时并不能保证原子性，对变量的操作可能就是很简单的 <code>i+=1</code>,但是底层需要多条字节码操作才能完成，在并发情况并不能保证原子性。</p>
<h3 id="禁止指令重排序优化"><a href="#禁止指令重排序优化" class="headerlink" title="禁止指令重排序优化"></a>禁止指令重排序优化</h3><p>   指令重排序是指CPU在正确处理指令依赖(数据依赖)并且保障程序执行得到正确结果的情况下，调整代码的执行顺序，允许将多条指令不按照程序规定顺序分开发送给各相应电路单元处理。需要注意的是指令重排序不会影响到代码在单线程环境下的执行，会影响到多线程并发情况下执行的正确性。</p>
<h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>如果让<code>volatile</code>保证原子性，必须符合以下两条规则：<br>1.运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；<br>2.变量不需要与其他的状态变量共同参与不变约束；</p>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>先行发生（<code>happens-before</code>）是判断数据是否存在竞争、线程是否安全的主要依据。如果A操作在B操作之前完成，那么B将观察到A执行的结果。<br><code>Java</code> 内存模型中存在着一些天然的先行发生关系：<br>1). 程序次序规则：在一个线程内，操作分先后，控制流顺序。<br>2). 管程锁定规则：一个<code>unlock</code>释放锁的操作先行发生于后面对同一个锁的<code>lock</code>加锁操作。<br>2). <code>volatile</code>变量规则：对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量的读操作。<br>2). 线程启动规则：<code>Thread</code>的<code>start()</code>方法先发生于对这个线程的所有操作。<br>5). 线程终止规则：现成的所有操作都先行发生于对此线程的终止操作。<br>6). 线程中断规则：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生。<br>7). 对象终结规则：一个对象的初始化完成先行发生于它的<code>finalize()</code> 方法。<br>8). 传递性：如果A操作先行发生于B操作，操作B先行发生于C操作，那么可以得出A操作先发生于C操作。</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/10/23/concurrent/线程与进程详解/">线程与进程详解</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-10-23
        </span>
        
          <span class="post-category">
            
              <a href="/categories/多线程/">多线程</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p>   进程是指处于运行过程中的程序，并且具有一定的独立功能。进程是系统进行资源分配和调度的一个单位。<br>   当程序进入内存运行时，即为进程。几乎所有的操作系统都支持多任务运行，而每个任务就是一个进程。<br>   当一个进程运行时，内部可以支持多个执行流程，而每个流程就是一个线程。    </p>
<h2 id="线程的定义"><a href="#线程的定义" class="headerlink" title="线程的定义"></a>线程的定义</h2><h3 id="线程的介绍"><a href="#线程的介绍" class="headerlink" title="线程的介绍"></a>线程的介绍</h3><pre><code>线程也称为轻型进程，因为线程只能在单个进程的作用域中使用，所以创建线程比创建进程要廉价得多。
线程是进程的组成部分，一个进程可以拥有多个线程，而一个线程只能属于单个进程。线程有自己的独立资源，比如栈，程序计数器，寄存器。
线程可以与当前进程中的其他线程共享进程资源。
</code></pre><h3 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h3><pre><code>线程之间可以协作完成任务。
线程之间是独立运行的，相互之间互不影响。
线程之间执行属于抢占式的，也就是说，线程的执行顺序是不一致的。
线程之间可以并发执行。 
</code></pre><h3 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h3><p>三种实现方式包括继承Thread， 实现Runnable, 使用ExecutorService、Callable、Future实现有返回结果的多线程。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread,线程:::"</span> + Thread.currentThread().getName() + <span class="string">" 正在执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Runnable,线程:::"</span> + Thread.currentThread().getName() + <span class="string">" 正在执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Callable,线程:::"</span> + Thread.currentThread().getName() + <span class="string">" 正在执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Callable,线程:::"</span> + Thread.currentThread().getName() + <span class="string">" 正在执行"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第一种继承Thread类"><a href="#第一种继承Thread类" class="headerlink" title="第一种继承Thread类"></a>第一种继承Thread类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">threadTest.start();</span><br><span class="line">ThreadTest threadTest1 = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">threadTest1.start();</span><br></pre></td></tr></table></figure>
<p>继承<code>Thread</code>的运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread,线程:::Thread-<span class="number">0</span> 正在执行</span><br><span class="line">Thread,线程:::Thread-<span class="number">1</span> 正在执行</span><br><span class="line">Thread,线程:::Thread-<span class="number">0</span> 正在执行</span><br><span class="line">Thread,线程:::Thread-<span class="number">1</span> 正在执行</span><br><span class="line">Thread,线程:::Thread-<span class="number">0</span> 正在执行</span><br><span class="line">Thread,线程:::Thread-<span class="number">1</span> 正在执行</span><br><span class="line">Thread,线程:::Thread-<span class="number">0</span> 正在执行</span><br><span class="line">Thread,线程:::Thread-<span class="number">0</span> 正在执行</span><br><span class="line">Thread,线程:::Thread-<span class="number">1</span> 正在执行</span><br><span class="line">Thread,线程:::Thread-<span class="number">1</span> 正在执行</span><br></pre></td></tr></table></figure>
<h4 id="第二种实现Runnable接口"><a href="#第二种实现Runnable接口" class="headerlink" title="第二种实现Runnable接口"></a>第二种实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现多线程</span></span><br><span class="line">RunnableTest runnableTest = <span class="keyword">new</span> RunnableTest();</span><br><span class="line">Thread threadTest2 = <span class="keyword">new</span> Thread(runnableTest);</span><br><span class="line">Thread threadTest3 = <span class="keyword">new</span> Thread(runnableTest);</span><br><span class="line">threadTest2.start();</span><br><span class="line">threadTest3.start();</span><br></pre></td></tr></table></figure>
<p>实现Runnable接口的运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Runnable,线程:::Thread-<span class="number">0</span> 正在执行</span><br><span class="line">Runnable,线程:::Thread-<span class="number">1</span> 正在执行</span><br><span class="line">Runnable,线程:::Thread-<span class="number">0</span> 正在执行</span><br><span class="line">Runnable,线程:::Thread-<span class="number">1</span> 正在执行</span><br><span class="line">Runnable,线程:::Thread-<span class="number">0</span> 正在执行</span><br><span class="line">Runnable,线程:::Thread-<span class="number">1</span> 正在执行</span><br><span class="line">Runnable,线程:::Thread-<span class="number">0</span> 正在执行</span><br><span class="line">Runnable,线程:::Thread-<span class="number">1</span> 正在执行</span><br><span class="line">Runnable,线程:::Thread-<span class="number">0</span> 正在执行</span><br><span class="line">Runnable,线程:::Thread-<span class="number">1</span> 正在执行</span><br></pre></td></tr></table></figure>
<h4 id="第三种使用ExecutorService、Callable、Future实现有返回结果的多线程"><a href="#第三种使用ExecutorService、Callable、Future实现有返回结果的多线程" class="headerlink" title="第三种使用ExecutorService、Callable、Future实现有返回结果的多线程"></a>第三种使用ExecutorService、Callable、Future实现有返回结果的多线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        CallableDemo callableDemo1 = <span class="keyword">new</span> CallableDemo();</span><br><span class="line">        CallableDemo callableDemo2 = <span class="keyword">new</span> CallableDemo();</span><br><span class="line">        Future future1 = executorService.submit(callableDemo1);</span><br><span class="line">        Future future2 = executorService.submit(callableDemo2);</span><br><span class="line">        future1.get(); <span class="comment">//如果调用返回Future对象的get()方法，会阻塞直到计算完成</span></span><br><span class="line">        future2.get();</span><br><span class="line">        executorService.shutdown();</span><br></pre></td></tr></table></figure>
<p>使用<code>ExecutorService</code>、<code>Callable</code>、<code>Future</code> 的运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Callable,线程:::pool-<span class="number">1</span>-thread-<span class="number">2</span> 正在执行</span><br><span class="line">Callable,线程:::pool-<span class="number">1</span>-thread-<span class="number">1</span> 正在执行</span><br><span class="line">Callable,线程:::pool-<span class="number">1</span>-thread-<span class="number">1</span> 正在执行</span><br><span class="line">Callable,线程:::pool-<span class="number">1</span>-thread-<span class="number">1</span> 正在执行</span><br><span class="line">Callable,线程:::pool-<span class="number">1</span>-thread-<span class="number">1</span> 正在执行</span><br><span class="line">Callable,线程:::pool-<span class="number">1</span>-thread-<span class="number">2</span> 正在执行</span><br><span class="line">Callable,线程:::pool-<span class="number">1</span>-thread-<span class="number">1</span> 正在执行</span><br><span class="line">Callable,线程:::pool-<span class="number">1</span>-thread-<span class="number">2</span> 正在执行</span><br><span class="line">Callable,线程:::pool-<span class="number">1</span>-thread-<span class="number">2</span> 正在执行</span><br><span class="line">Callable,线程:::pool-<span class="number">1</span>-thread-<span class="number">2</span> 正在执行</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/09/16/LinkedList/">LinkedList的源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-09-16
        </span>
        
          <span class="post-category">
            
              <a href="/categories/JAVA-集合/">JAVA 集合</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="LinkedList-简介"><a href="#LinkedList-简介" class="headerlink" title="LinkedList 简介"></a>LinkedList 简介</h2><p><code>LinkedList</code> 是继承于<code>AbstractSequentialList</code>的双向链表， 它可以被当做堆栈，队列或双端队列使用。<br><code>LinkedList</code> 实现了<code>List</code>接口， 能对它进行队列操作。<br><code>LinkedList</code> 实现了<code>Cloneable</code>接口， 覆盖了函数<code>clone()</code>, 支持克隆。<br><code>LinkedList</code> 实现了<code>Deque</code>接口， 能将 <code>LinkedList</code>当做双端队列使用。<br><code>LinkedList</code> 实现了<code>Serializable</code>接口，意味着支持序列化， 便于在网络中传输和保存。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedList</code> 是采用链表的方式来实现<code>List</code>接口的,它本身有自己特定的方法，  如: <code>addFirst()</code>,<code>addLast()</code>,<code>getFirst()</code>,<code>getLast()</code>,<code>removeFirst()</code>，<code>removeFirst()</code>，<code>removeLast()</code>。</p>
<h2 id="元素的插入与获取"><a href="#元素的插入与获取" class="headerlink" title="元素的插入与获取"></a>元素的插入与获取</h2><h4 id="addFirst-和-addLast"><a href="#addFirst-和-addLast" class="headerlink" title="addFirst() 和 addLast()"></a>addFirst() 和 addLast()</h4><p>直接插入头部元素 和 尾部元素实现方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f); <span class="comment">//构造头部对象</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="comment">//如果f为空，则first == last</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;  <span class="comment">//否则 头节点为newNode</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//默认的添加方式也是由此方法实现    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>); <span class="comment">//构造尾部对象</span></span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>) <span class="comment">//如果l为空，则first == last</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode; <span class="comment">//否则，尾节点为newNode</span></span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="getFirst-和-getLast"><a href="#getFirst-和-getLast" class="headerlink" title="getFirst() 和 getLast()"></a>getFirst() 和 getLast()</h4><p>直接获取头部元素 和 尾部元素实现方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>LinkedList</code> 查找元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123; <span class="comment">//判断index 是否为 list size 的 一半</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) <span class="comment">// 从 0 ~ index 中循环遍历 </span></span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) <span class="comment">// 从 index ~ zize - 1 中遍历</span></span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="由此得出结论："><a href="#由此得出结论：" class="headerlink" title="由此得出结论："></a>由此得出结论：</h4><p>  <code>LinkedList</code> 采用了链表结构，所以在添加和删除方面效率高，查找比较慢  </p>
<h2 id="元素的删除"><a href="#元素的删除" class="headerlink" title="元素的删除"></a>元素的删除</h2><h4 id="removeFirst-和-removeLast"><a href="#removeFirst-和-removeLast" class="headerlink" title="removeFirst() 和 removeLast()"></a>removeFirst() 和 removeLast()</h4><p><code>LinkedList</code> 移除首个元素 和 移除最后一个元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//removeFirst 主要实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="keyword">null</span>; <span class="comment">//将当前元素清空</span></span><br><span class="line">        f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;  <span class="comment">//指针后移</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>; <span class="comment">//将节点prev置空</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//removeLast 主要实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = l.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="keyword">null</span>; <span class="comment">//将当前元素清空</span></span><br><span class="line">        l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev; <span class="comment">//指针前移</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="keyword">null</span>; <span class="comment">//将节点next置空</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要移除元素底层实现(根据下标移除，根据元素移除)<br>链表结构图如下：<br><img src="https://dj-cdn.g2work.com/2018/09/29/bc14a140-e1d6-41ca-8ea8-75ff8ac14099.png?imageMogr2/auto-orient" alt=""><br>将链表重新组装<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next; <span class="comment">//获取当前节点下一节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev; <span class="comment">//获取当前节点上一节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123; <span class="comment">//如果上一节点为空，则首节点下一节点</span></span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//将上一节点的下一节点替换为当前元素的下一节点</span></span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123; <span class="comment">//如果下一节点为空，则尾节点上一节点</span></span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//将下一节点的上一节点替换为当前元素的下一节点</span></span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="LinkedList-用作堆栈"><a href="#LinkedList-用作堆栈" class="headerlink" title="LinkedList 用作堆栈"></a>LinkedList 用作堆栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedList 实现堆栈的先进后出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将每次添加的元素都添加到第一个位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        linkedList.addFirst(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取出第一个元素但是不删除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> linkedList.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取出并移除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> linkedList.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取元素个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> linkedList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆栈是否为空 </span></span><br><span class="line"><span class="comment">     * (即判断 linkedList是否为空) </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> linkedList.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackDemo stackDemo = <span class="keyword">new</span> StackDemo();</span><br><span class="line">        stackDemo.push(<span class="string">"1"</span>);</span><br><span class="line">        stackDemo.push(<span class="string">"2"</span>);</span><br><span class="line">        stackDemo.push(<span class="string">"3"</span>);</span><br><span class="line">        stackDemo.push(<span class="string">"4"</span>);</span><br><span class="line">        stackDemo.push(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"取出第一个元素：：：："</span> + stackDemo.peek());</span><br><span class="line">        System.out.println(<span class="string">"取出第一个元素：：：："</span> + stackDemo.poll());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stackDemo.isEmpty()) &#123;</span><br><span class="line">            System.out.print(stackDemo.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedList</code> 用作堆栈 输出结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">插入第<span class="number">1</span>个元素,值为 <span class="number">1</span></span><br><span class="line">插入第<span class="number">2</span>个元素,值为 <span class="number">2</span></span><br><span class="line">插入第<span class="number">3</span>个元素,值为 <span class="number">3</span></span><br><span class="line">插入第<span class="number">4</span>个元素,值为 <span class="number">4</span></span><br><span class="line">插入第<span class="number">5</span>个元素,值为 <span class="number">5</span></span><br><span class="line">取出第一个元素 <span class="number">5</span></span><br><span class="line">取出第一个元素 <span class="number">5</span></span><br><span class="line">输出顺序为 <span class="number">4</span></span><br><span class="line">输出顺序为 <span class="number">3</span></span><br><span class="line">输出顺序为 <span class="number">2</span></span><br><span class="line">输出顺序为 <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="LinkedList-用作队列"><a href="#LinkedList-用作队列" class="headerlink" title="LinkedList 用作队列"></a>LinkedList 用作队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedList 实现先进先出队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="comment">//offer()方法是往队列尾部加入元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            queue.offer(i + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"插入第"</span>+ (i + <span class="number">1</span>) +<span class="string">"个元素,"</span> + <span class="string">"值为 "</span> + (i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"输出顺序 "</span> + queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">插入第<span class="number">1</span>个元素,值为 <span class="number">1</span></span><br><span class="line">插入第<span class="number">2</span>个元素,值为 <span class="number">2</span></span><br><span class="line">插入第<span class="number">3</span>个元素,值为 <span class="number">3</span></span><br><span class="line">插入第<span class="number">4</span>个元素,值为 <span class="number">4</span></span><br><span class="line">插入第<span class="number">5</span>个元素,值为 <span class="number">5</span></span><br><span class="line">输出顺序 <span class="number">1</span></span><br><span class="line">输出顺序 <span class="number">2</span></span><br><span class="line">输出顺序 <span class="number">3</span></span><br><span class="line">输出顺序 <span class="number">4</span></span><br><span class="line">输出顺序 <span class="number">5</span></span><br></pre></td></tr></table></figure></p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/09/15/LinkedHashMap/">LinkedHashMap的源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-09-15
        </span>
        
          <span class="post-category">
            
              <a href="/categories/JAVA-集合/">JAVA 集合</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="LinkedHashMap-简介"><a href="#LinkedHashMap-简介" class="headerlink" title="LinkedHashMap 简介"></a>LinkedHashMap 简介</h2><p> <code>LinkedHashMap</code> 继承了 <code>HashMap</code>, 实现了<code>map</code>接口。<br> 所以 <code>LinkedHashMap</code> 包含了 <code>HashMap</code> 的所有功能， 它是一个关联数组，线程不安全，并且<code>key</code>值，<code>value</code>值允许为空。<br><code>LinkedHashMap</code> 与 <code>HashMap</code> 不同之处是它支持写入顺序排序，访问顺序排序。  </p>
<h3 id="顺序展示效果示例代码"><a href="#顺序展示效果示例代码" class="headerlink" title="顺序展示效果示例代码"></a>顺序展示效果示例代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">    map.put(<span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">"2"</span>, <span class="number">2</span>);</span><br><span class="line">    map.put(<span class="string">"3"</span>, <span class="number">3</span>);</span><br><span class="line">    map.put(<span class="string">"4"</span>, <span class="number">4</span>);</span><br><span class="line">    map.put(<span class="string">"5"</span>, <span class="number">5</span>);</span><br><span class="line">    Iterator iterator = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iterator.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"::"</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"accessOrder  设置为 true"</span>);</span><br><span class="line">    Map mapOrder = <span class="keyword">new</span> LinkedHashMap(<span class="number">15</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    mapOrder.put(<span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line">    mapOrder.put(<span class="string">"2"</span>, <span class="number">2</span>);</span><br><span class="line">    mapOrder.put(<span class="string">"3"</span>, <span class="number">3</span>);</span><br><span class="line">    mapOrder.put(<span class="string">"4"</span>, <span class="number">4</span>);</span><br><span class="line">    mapOrder.put(<span class="string">"5"</span>, <span class="number">5</span>);</span><br><span class="line">    mapOrder.get(<span class="string">"1"</span>);</span><br><span class="line">    Iterator iterator1 = mapOrder.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iterator1.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"::"</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">返回的结果如下：  </span><br><span class="line">写入顺序排序</span><br><span class="line"><span class="number">1</span>::<span class="number">1</span></span><br><span class="line"><span class="number">2</span>::<span class="number">2</span></span><br><span class="line"><span class="number">3</span>::<span class="number">3</span></span><br><span class="line"><span class="number">4</span>::<span class="number">4</span></span><br><span class="line"><span class="number">5</span>::<span class="number">5</span></span><br><span class="line">accessOrder  设置为 <span class="keyword">true</span></span><br><span class="line">访问顺序排序</span><br><span class="line"><span class="number">2</span>::<span class="number">2</span></span><br><span class="line"><span class="number">3</span>::<span class="number">3</span></span><br><span class="line"><span class="number">4</span>::<span class="number">4</span></span><br><span class="line"><span class="number">5</span>::<span class="number">5</span></span><br><span class="line"><span class="number">1</span>::<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>带着疑问剖析源码，<code>LinkedHashMap</code>的构造函数有五种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认是false，则迭代时输出的顺序是插入节点的顺序。若为true，则输出的顺序是按照访问节点的顺序。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line"><span class="comment">//指定初始化时的容量，和扩容的加载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始化时的容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用另一个Map 来构建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始化时的容量，和扩容的加载因子，以及迭代输出节点的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数和<code>HashMap</code>相比，就是增加了一个<code>accessOrder</code>参数。用于控制迭代时的节点顺序。    </p>
<h3 id="LinkedHashMap的添加"><a href="#LinkedHashMap的添加" class="headerlink" title="LinkedHashMap的添加"></a>LinkedHashMap的添加</h3><p>在<code>LinkedHashMap</code>中没有重写<code>HashMap</code>的<code>put</code>方法，但是重写了<code>HashMap</code>中的<code>newNode</code> 方法，<br>在每次构建新节点时，通过<code>linkNodeLast(p)</code>，将新节点链接在内部双向链表的尾部。<br>源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在构建新节点时，构建的是`LinkedHashMap.Entry` 不再是`Node`.</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次插入数据是插入到尾节点，并且把方插入的节点的before设置为last</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LinkedHashMap的删除"><a href="#LinkedHashMap的删除" class="headerlink" title="LinkedHashMap的删除"></a>LinkedHashMap的删除</h3><p><code>LinkedHashMap</code>也没有重写<code>remove()</code>方法，因为它的删除逻辑和<code>HashMap</code>并无区别。<br>重点在于<code>LinkedHashMap</code> 重写了 <code>afterNodeRemoval</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.before = p.after = <span class="keyword">null</span>;<span class="comment">//待删除节点 p 的前置后置节点都置空</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a; <span class="comment">//重新关联b的after节点</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            tail = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = b; <span class="comment">//重新关联a的before节点</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LinkedHashMap的查找"><a href="#LinkedHashMap的查找" class="headerlink" title="LinkedHashMap的查找"></a>LinkedHashMap的查找</h3><p><code>LinkedHashMap</code> 重写了 <code>get()</code> 和 <code>getOrDefault()</code> 方法。<br>对比<code>HashMap</code>的实现可以发现只是增加了在成员变量(构造函数时赋值)accessOrder = true 的情况下会调用 <code>afterNodeAccess()</code> 方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> defaultValue;</span><br><span class="line">   <span class="keyword">if</span> (accessOrder)</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">   <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此方法的目的是将不是尾部的元素并且accessOrder = true的节点e移动至内部的双向链表的尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>; <span class="comment">//将p的设置为尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) <span class="comment">// 如果p的前置节点为null，则p以前是头节点，所以更新现在的头节点为p的后置节点a</span></span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则更新b的后置节点为a</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) <span class="comment">// 如果p的后置节点不为null， 则更新a的前置节点为b</span></span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 如果p的后置节点为null，则p就是尾节点，更新last 引用为b</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">//如果尾节点为空，则链表中只有一个节点</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// 否则更新更新p的前置节点为原尾节点last，last的后置节点为p</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;<span class="comment">//尾节点的引用赋值成p</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/09/14/HashSet/">HashSet的源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-09-14
        </span>
        
          <span class="post-category">
            
              <a href="/categories/JAVA-集合/">JAVA 集合</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="HashSet-简介"><a href="#HashSet-简介" class="headerlink" title="HashSet 简介"></a>HashSet 简介</h2><p><code>HashSet</code> 是一个没有重复元素的集合。<br>它是由 <code>HashMap</code> 实现的， 无序且允许空值。<br><code>HashSet</code> 是非线程同步的，没有提供数据访问保护，在多线程环境中容易导致多个线程更改数据后造成数据脏读。  </p>
<p><code>HashSet</code> 的添加方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map是一个HashMap&lt;E, Object&gt;对象，HashSet是由一个HashMap实例支持的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">//PRESENT是一个static final Object对象，用来作为HashMap中的value值。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//熟悉hashmap的实现方式的话很容易理解put方法，对象作为key值，不允许重复，value使用 PRESENT。   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>HashSet</code> 的查找方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果此set包含指定元素，则返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>HashSet</code> 的清空与移除方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果指定元素存在于此set中，则将其移除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从此set中移除所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HashSet</code> 的遍历方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">set.add(<span class="string">"!"</span>);</span><br><span class="line">set.add(<span class="string">"a"</span>);</span><br><span class="line">set.add(<span class="string">"1"</span>);</span><br><span class="line">Iterator iterator = set.iterator();</span><br><span class="line"><span class="comment">//通过keyset的方式获取key值集合的迭代器</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String key = (String) iterator.next();</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/09/13/HashMap/">HashMap的源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-09-13
        </span>
        
          <span class="post-category">
            
              <a href="/categories/JAVA-集合/">JAVA 集合</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h2><p><code>HashMap</code> 是一个散列表， 它存储的内容是键值对<code>（key -  value）</code>映射。<br><code>HashMap</code> 继承于 <code>AbstractMap</code>， 实现了<code>Map</code>， <code>Cloneable</code>，<code>Serializable</code> 接口。<br><code>HashMap</code> 不是线程安全的， 不适用于多线程中， 此外，<code>HashMap</code>中的映射不是有序的。<br><code>HashMap</code> 里面是一个数组，然后数组中每个元素是一个单项链表。<br>图中<code>Entry</code> 包含四个属性，<code>key</code>，<code>value</code>，<code>hash</code> 值和用于单项链表的<code>next</code>。  </p>
<p>重要参数<code>capacity</code> 和 <code>loadFactor</code>。<br><code>capacity</code> 当前数组容量，始终保持 2^n，默认值为 <code>1&lt;&lt;4</code>，最大为 <code>1&lt;&lt;16</code>, 可以扩容，扩容后数组大小为当前的 2 倍。<br><code>loadFactor</code> 负载因子，默认为 0.75。<br><code>threshold</code> 扩容的阈值，等于 <code>capacity * loadFactor</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>HashMap</code> 的 <code>put</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);    <span class="comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p; <span class="comment">//首先，判断该位置的第一个数据和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                      <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个</span></span><br><span class="line">                      <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">          <span class="comment">// e!=null 说明存在旧值的key与要插入的key"相等"</span></span><br><span class="line">                 <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 "值覆盖"，然后返回旧值</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">接下来看 hashmap 的 resize 方法</span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HashMap</code> 的 <code>get</code>方法<br>1.计算   <code>key</code> 的 <code>hash</code> 值，根据 <code>hash</code> 值找到对应数组下标: <code>hash &amp; (length-1)</code><br>2.判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步<br>3.判断该元素类型是否是 <code>TreeNode</code>，如果是，用红黑树的方法取数据，如果不是，走第四步<br>4.遍历链表，直到找到相等<code>(==或equals)的 key</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="number">3</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="number">4</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/09/12/ConcurrentHashMap/">ConcurrentHashMap的源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-09-12
        </span>
        
          <span class="post-category">
            
              <a href="/categories/JAVA-集合/">JAVA 集合</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="ConcurrentHashMap-简介"><a href="#ConcurrentHashMap-简介" class="headerlink" title="ConcurrentHashMap 简介"></a>ConcurrentHashMap 简介</h2><p> 正是由于<code>HashMap</code> 不是线程安全的，所以大佬给我们带来了 线程安全的<code>ConcurrentHashMap</code>。<br> 本文的分析的源码是JDK8的版本，与JDK7的版本有很大的差异，java7中 <code>ConcurrentHashMap</code> 由 <code>Segment</code> 数组、<code>HashEntry</code> 组成，和 <code>HashMap</code> 一样，仍然是数组加链表。<br> 它摒弃了<code>Segment</code>（锁段）的概念，而是启用了一种全新的方式实现,利用<code>CAS</code>算法。它沿用了与它同时期的<code>HashMap</code>版本的思想，底层依然由“数组”+链表+红黑树的方式思想，<br> 但是为了做到并发，又增加了很多辅助的类，例如<code>TreeBin</code>，<code>Traverser</code>等对象内部类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">hashmap 的 Node 类</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">concurrentHashMap 的 Node 类</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>concurrentHashMap</code>的 <code>val next</code> 都用了 <code>volatile</code> 修饰，保证了元素可见性。 </p>
<h3 id="concurrentHashMap的添加方法"><a href="#concurrentHashMap的添加方法" class="headerlink" title="concurrentHashMap的添加方法"></a>concurrentHashMap的添加方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());  (<span class="number">1</span>). 根据 key 计算出 hashcode 。</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) (<span class="number">2</span>). 判断是否需要进行初始化。</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123; (<span class="number">3</span>). 根据key的hash值和容器的容量减一后进行与运算定位。如果为空就尝试使用cas插入数据</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) (<span class="number">4</span>). 如果当前位置的 hashcode == MOVED == -<span class="number">1</span>,则需要进行扩容。</span><br><span class="line">            tab = helpTransfer(tab, f); </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; (<span class="number">5</span>). 如果都不满足，则利用 <span class="keyword">synchronized</span> 锁写入数据。</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">//链表节点</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">//树节点，与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode.</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);  (<span class="number">6</span>). 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>concurrentHashMap</code> 定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了<code>ConcurrentHashMap</code>的线程安全。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">此函数用于比较tab数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line">利用<span class="keyword">volatile</span>方法设置节点位置的值</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="concurrentHashMap的获取方法"><a href="#concurrentHashMap的获取方法" class="headerlink" title="concurrentHashMap的获取方法"></a>concurrentHashMap的获取方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123; (<span class="number">1</span>). 根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) (<span class="number">2</span>). 如果是红黑树那就按照树的方式获取值。</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123; (<span class="number">3</span>). 都不满足那就按照链表的方式遍历获取值。</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/09/11/ArrayList/">ArrayList/Vector的源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-09-11
        </span>
        
          <span class="post-category">
            
              <a href="/categories/JAVA-集合/">JAVA 集合</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p><code>ArrayList</code> 是动态数组，其实就是<code>Array</code>的复杂版本，它提供了动态增加和减少元素的功能，实现了<code>List</code>，<code>RandomAccess</code>, <code>Collection</code>接口，<code>ArrayList</code>不是线程安全的，建议在单线程中使用<code>ArrayList</code>。</p>
<p><code>ArrayList</code> 包含两个重要属性分别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* elementData；</span></span><br><span class="line"><span class="comment">* transient 关键字修饰表示防止此字段被序列化</span></span><br><span class="line"><span class="comment">* 避免了浪费资源去存储没有的数据</span></span><br><span class="line"><span class="comment">* size:</span></span><br><span class="line"><span class="comment">* elementData中已存放的元素的个数，注意：不是elementData的容量</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<p>因为 <code>elementData</code>无法被序列化， 所以<code>ArrayList</code> 的序列化和反序列化依赖<code>writeObject</code> 和 <code>readObject</code>方法来实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span></span><br><span class="line"><span class="comment"> * is, serialize it).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serialData</span> The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment"> *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span></span><br><span class="line"><span class="comment"> * deserialize it).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>往<code>ArrayList</code> 中添加元素单个元素有两种方式<br>第一种：将单个元素添加到尾部，并将<code>size</code> + 1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向elementData中添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ensureCapacityInternal(<span class="keyword">this</span>.size + <span class="number">1</span>);<span class="comment">//确保对象数组elementData有足够的容量，可以将新加入的元素e加进去</span></span><br><span class="line">    <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.size++] = var1;<span class="comment">//加入新元素e，size加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保数组的容量足够存放新加入的元素，若不够，要扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//获取数组大小（即数组的容量）</span></span><br><span class="line">    <span class="comment">//当数组满了，又有新元素加入的时候，执行扩容逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;</span><br><span class="line">        Object oldData[] = elementData;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>) / <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//新容量为旧容量的1.5倍+1</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; minCapacity)<span class="comment">//如果扩容后的新容量还是没有传入的所需的最小容量大或等于（主要发生在addAll(Collection&lt;? extends E&gt; c)中）</span></span><br><span class="line">            newCapacity = minCapacity;<span class="comment">//新容量设为最小容量</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//复制新容量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种：将单个元素添加到指定位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);<span class="comment">//确保对象数组elementData有足够的容量，可以将新加入的元素e加进去</span></span><br><span class="line">    </span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);<span class="comment">//复制数组，将值往后移动</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加元素时判断elementData是否为空，为空则设置elementData的大小为10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见两种添加方式前者比后者节省资源消耗。</p>
<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p><code>Vector</code> 也是实现于<code>List</code>接口，底层数据结构和<code>ArrayList</code>类似，也是动态数组存放数据，不过是在 <code>add()</code> 方法的时候使用 <code>synchronized</code> 进行同步写数据，与<code>ArrayList</code>不同的是<code>Vector</code> 线程安全，但是开销较大，所以 <code>Vector</code> 是一个同步容器并不是一个并发容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在对象数组中尾部添加单个元素和在指定位置添加单个元素</span></span><br><span class="line"><span class="comment">* 使用synchronized 进行同步写数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

      
      
  <nav class="pagination">
    
    
  </nav>


    
  </section>

          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:gentle.taoxue@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/Brooke-Paul" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Brooke-Paul</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script>

  </body>
</html>
